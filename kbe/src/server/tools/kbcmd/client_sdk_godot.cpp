/*
This source file is part of KBEngine
For the latest info, see http://www.kbengine.org/

Copyright (c) 2008-2018 KBEngine.

KBEngine is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

KBEngine is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.
 
You should have received a copy of the GNU Lesser General Public License
along with KBEngine.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "kbcmd.h"
#include "client_sdk.h"
#include "client_sdk_godot.h"	
#include "entitydef/entitydef.h"
#include "entitydef/scriptdef_module.h"
#include "entitydef/property.h"
#include "entitydef/method.h"
#include "entitydef/datatype.h"
#include "network/fixed_messages.h"

namespace KBEngine {	

static std::string headerBody = "#Generated by KBEngine!\n#Please do not modify this file!\n#tool: kbcmd\n\n\n";
static std::string moduleSuffix = "Base";

//-------------------------------------------------------------------------------------
ClientSDKGodot::ClientSDKGodot():
	ClientSDK(),
	initBody_()
{
}

//-------------------------------------------------------------------------------------
ClientSDKGodot::~ClientSDKGodot()
{

}

//-------------------------------------------------------------------------------------
std::string ClientSDKGodot::typeToType(const std::string& type)
{
	return "var";
}

//-------------------------------------------------------------------------------------
void ClientSDKGodot::onCreateTypeFileName()
{
	sourcefileName_ = "KBETypes.gd";
}

//-------------------------------------------------------------------------------------
void ClientSDKGodot::onCreateEntityModuleFileName(const std::string& moduleName)
{
	sourcefileName_ = moduleName + moduleSuffix + ".gd";
}

//-------------------------------------------------------------------------------------
void ClientSDKGodot::onCreateServerErrorDescrsModuleFileName()
{
	sourcefileName_ = "ServerErrorDescrs.gd";
}

//-------------------------------------------------------------------------------------
void ClientSDKGodot::onCreateEngineMessagesModuleFileName()
{
	sourcefileName_ = "Messages.gd";
}

//-------------------------------------------------------------------------------------
void ClientSDKGodot::onCreateDefsCustomTypesModuleFileName()
{
	sourcefileName_ = "CustomDataTypes.gd";
}

//-------------------------------------------------------------------------------------
bool ClientSDKGodot::writeServerErrorDescrsModuleBegin()
{
	sourcefileBody_ = headerBody;

	sourcefileBody_ += "#ServerErrorDescrs\n#defined in */res/server/server_errors.xml\n\n";
	
	sourceFileBody += "class ServerErr:\n\tvar name\n\tvar descr\n\tvar id\n\n"
	
	sourcefileBody_ += "var serverErrs = {}\n\n";
	
	sourcefileBody_ += "func addServerErr(id, name, descr):\n";
	sourcefileBody_ += "\tvar e = ServerErr.new()\n";
	sourcefileBody_ += "\te.id = id\n";
	sourcefileBody_ += "\te.name = name\n";
	sourcefileBody_ += "\te.descr = descr\n\n";
	sourcefileBody_ += "\tserverErrs[id] = e\n\n";

	sourcefileBody_ += "func _init():\n";
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKGodot::writeServerErrorDescrsModuleErrDescr(int errorID, const std::string& errname, const std::string& errdescr)
{
	sourcefileBody_ += fmt::format("\taddServerErr({}, {}, {})\n", errorID, errname, errdescr);
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKGodot::writeServerErrorDescrsModuleEnd()
{
	sourcefileBody_ += "\nfunc clear():\n\tserverErrs.clear()\n\n";

	sourcefileBody_ += "func serverErrStr(id):\n";
	sourcefileBody_ += "\tif serverErrs.has(id):\n\t\treturn serverErrs[id].name+'['+serverErrs[id].descr+']'\n";
	sourcefileBody_ += "\telse:\n\t\treturn ''\n\n";

	sourcefileBody_ += "func serverErr(id):\n";
	sourcefileBody_ += "\tif serverErrs.has(id):\n\t\treturn serverErrs[id]\n";
	sourcefileBody_ += "\telse:\n\t\treturn ServerErr.new()\n\n";
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKGodot::writeEngineMessagesModuleBegin()
{
	initBody_ = "";
	sourcefileBody_ = headerBody;

	sourcefileBody_ += "var MessageReader = preload('res://kbe_plugin/MessageReader.gd')\n\n";
	
	sourcefileBody_ += "class Message:";
	
	sourcefileBody_ += "\tvar id = 0\n";
	sourcefileBody_ += "\tvar name = \"\"\n";
	sourcefileBody_ += "\tvar msglen = -1\n";
	sourcefileBody_ += "\tvar argtypes = null\n";
	sourcefileBody_ += "\tvar argsType = 0\n\n";

	sourcefileBody_ += "\tfunc _init(msgid, msgname, length, argstype, msgargtypes):\n";
	sourcefileBody_ += "\t\tid = msgid\n";
	sourcefileBody_ += "\t\tname = msgname\n";
	sourcefileBody_ += "\t\tmsglen = length\n";
	sourcefileBody_ += "\t\targsType = argstype\n\n";

	sourcefileBody_ += "\t\targtypes = msgargtypes\n\n";

	sourcefileBody_ += "\tfunc handleMessage(msgstream):\n\t\tpass\n\n";
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKGodot::writeEngineMessagesModuleMessage(Network::ExposedMessageInfo& messageInfos, COMPONENT_TYPE componentType)
{
	sourcefileBody_ += fmt::format("class Message_{} extends Message:\n", messageInfos.name);

	sourcefileBody_ += "\tfunc _init(msgid, msgname, length, argstype, msgargtypes).(msgid, msgname, length, argstype, msgargtypes):\n\t\tpass\n\n";

	sourcefileBody_ += "\tfunc handleMessage(msgstream):\n";

	if (messageInfos.argsTypes.size() == 0)
	{
		initBody_ += fmt::format("\tKBEngine.Messages.messages['{}'] = KBEngine.Messages.Message_{}.new({}, '{}', {}, {}, [])\n", 
			messageInfos.name, messageInfos.name, messageInfos.id, messageInfos.name, messageInfos.msgLen, (int)messageInfos.argsType);

		if (componentType == CLIENT_TYPE)
		{
			if (messageInfos.argsType < 0)
			{
				sourcefileBody_ += fmt::format("\t\tKBEngine.app.{}(msgstream)\n", messageInfos.name);
			}
			else
			{
				sourcefileBody_ += fmt::format("\t\tKBEngine.app.{}()\n", messageInfos.name);
			}
		}
	}
	else
	{
		std::string argsparse = "";
		std::string giveargs = "";
		initBody_ += fmt::format("\n\tvar {}_argstypes = []\n", messageInfos.name);

		for (int i = 0; i < (int)messageInfos.argsTypes.size(); ++i)
		{
			int argindex = (i + 1);
			std::string nativetype = datatype2nativetype(messageInfos.argsTypes[i]);

			KBE_ASSERT(nativetype != "FIXED_DICT" && nativetype != "ARRAY" && nativetype != "PYTHON" && nativetype != "ENTITYCALL");

			std::string readName = nativetype;
			std::transform(readName.begin(), readName.end(), readName.begin(), tolower);
			readName[0] = std::toupper(readName[0]);

			argsparse += fmt::format("\t\tvar arg{} = msgstream.read{}()\n", argindex, readName);
			giveargs += fmt::format("arg{}, ", argindex);
			initBody_ += fmt::format("\t{}_argstypes.Add({})\n", messageInfos.name, (int)messageInfos.argsTypes[i]);
		}

		if (giveargs.size() > 0)
			giveargs.erase(giveargs.size() - 2, 2);

		initBody_ += fmt::format("\tKBEngine.Messages.messages['{}'] = KBEngine.Messages.Message_{}.new({}, '{}', {}, {}, {}_argstypes)\n", 
			messageInfos.name, messageInfos.name, messageInfos.id, messageInfos.name, messageInfos.msgLen, (int)messageInfos.argsType, messageInfos.name);
		
		if (componentType == CLIENT_TYPE)
		{
			sourcefileBody_ += argsparse;
			sourcefileBody_ += fmt::format("\t\tKBEngine.app.{}({})\n", messageInfos.name, giveargs);
		}
	}

	if (componentType == CLIENT_TYPE)
	{
		initBody_ += fmt::format("\tKBEngine.Messages.clientMessages[{}] = KBEngine.Messages.messages['{}']\n\n", messageInfos.id, messageInfos.name);
	}
	else if (componentType == LOGINAPP_TYPE)
	{
		initBody_ += fmt::format("\tKBEngine.Messages.loginappMessages[{}] = KBEngine.Messages.messages['{}']\n\n", messageInfos.id, messageInfos.name);
	}
	else if (componentType == BASEAPP_TYPE)
	{
		initBody_ += fmt::format("\tKBEngine.Messages.baseappMessages[{}] = KBEngine.Messages.messages['{}']\n\n", messageInfos.id, messageInfos.name);
	}

	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKGodot::writeEngineMessagesModuleEnd()
{
	sourcefileBody_ += "var loginappMessages = {}\n";
	sourcefileBody_ += "var baseappMessages = {}\n";
	sourcefileBody_ += "var clientMessages = {}\n";
	sourcefileBody_ += "var messages = {}\n\n";
	
	sourcefileBody_ += "func clear():\n\tloginappMessages = {}\n\tbaseappMessages = {}\n\tclientMessages = {}\n\tmessages = {}\n\n\tinit()\n\n";

	sourcefileBody_ += "func init():\n";

	sourcefileBody_ += initBody_;

	sourcefileBody_ += "\n\treturn true";
	return true;
}

//-------------------------------------------------------------------------------------
void ClientSDKGodot::onCreateEntityDefsModuleFileName()
{
	sourcefileName_ = "EntityDef.gd";
}

//-------------------------------------------------------------------------------------
bool ClientSDKGodot::writeEntityDefsModuleBegin()
{
	initBody_ = "";
	sourcefileBody_ = headerBody;

	sourcefileBody_ += "EntityDef module\n\n";

	sourcefileBody_ += "var datatype2id = {}\n";
	sourcefileBody_ += "var datatypes = {}\n";
	sourcefileBody_ += "var id2datatypes = {}\n";
	sourcefileBody_ += "var entityclass = {}\n";
	sourcefileBody_ += "var moduledefs = {}\n";
	sourcefileBody_ += "var idmoduledefs = {}\n";

	sourcefileBody_ += "func init():\n";
	sourcefileBody_ += "\tinitDataTypes()\n";
	sourcefileBody_ += "\tinitDefTypes()\n";
	sourcefileBody_ += "\tinitScriptModules()\n";
	sourcefileBody_ += "\treturn true\n\n";

	sourcefileBody_ += "func reset():\n";
	sourcefileBody_ += "\tclear()\n";
	sourcefileBody_ += "\treturn init()\n\n";

	sourcefileBody_ += "func clear():\n";
	sourcefileBody_ += "\tdatatype2id.clear()\n";
	sourcefileBody_ += "\tdatatypes.clear()\n";
	sourcefileBody_ += "\tid2datatypes.clear()\n";
	sourcefileBody_ += "\tentityclass.clear()\n";
	sourcefileBody_ += "\tmoduledefs.clear()\n";
	sourcefileBody_ += "\tidmoduledefs.clear()\n\n";

	sourcefileBody_ += "func initDataTypes():\n";
	sourcefileBody_ += "\tdatatypes[\"UINT8\"] = KBEngine.Datatypes.UINT8.new()\n";
	sourcefileBody_ += "\tdatatypes[\"UINT16\"] = KBEngine.Datatypes.UINT16.new()\n";
	sourcefileBody_ += "\tdatatypes[\"UINT32\"] = KBEngine.Datatypes.UINT32.new()\n";
	sourcefileBody_ += "\tdatatypes[\"UINT64\"] = KBEngine.Datatypes.UINT64.new()\n\n";

	sourcefileBody_ += "\tdatatypes[\"INT8\"] = KBEngine.Datatypes.INT8.new()\n";
	sourcefileBody_ += "\tdatatypes[\"INT16\"] = KBEngine.Datatypes.INT16.new()\n";
	sourcefileBody_ += "\tdatatypes[\"INT32\"] = KBEngine.Datatypes.INT32.new()\n";
	sourcefileBody_ += "\tdatatypes[\"INT64\"] = KBEngine.Datatypes.INT64.new()\n\n";

	sourcefileBody_ += "\tdatatypes[\"FLOAT\"] = KBEngine.Datatypes.FLOAT.new()\n";
	sourcefileBody_ += "\tdatatypes[\"DOUBLE\"] = KBEngine.Datatypes.DOUBLE.new()\n\n";

	sourcefileBody_ += "\tdatatypes[\"STRING\"] = KBEngine.Datatypes.STRING.new()\n";
	sourcefileBody_ += "\tdatatypes[\"VECTOR2\"] = KBEngine.Datatypes.VECTOR2.new()\n\n";
	sourcefileBody_ += "\tdatatypes[\"VECTOR3\"] = KBEngine.Datatypes.VECTOR3.new()\n\n";
	sourcefileBody_ += "\tdatatypes[\"VECTOR4\"] = KBEngine.Datatypes.VECTOR4.new()\n";
	sourcefileBody_ += "\tdatatypes[\"PYTHON\"] = KBEngine.Datatypes.PYTHON.new()\n\n";
	sourcefileBody_ += "\tdatatypes[\"UNICODE\"] = KBEngine.Datatypes.UNICODE.new()\n";
	sourcefileBody_ += "\tdatatypes[\"ENTITYCALL\"] = KBEngine.Datatypes.ENTITYCALL.new()\n\n";
	sourcefileBody_ += "\tdatatypes[\"BLOB\"] = KBEngine.Datatypes.BLOB.new()\n\n";

	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKGodot::writeEntityDefsModuleEnd()
{
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKGodot::writeEntityDefsModuleInitScriptBegin()
{
	sourcefileBody_ += "func initScriptModules()\n";
	sourcefileBody_ += "\t\t{\n";
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKGodot::writeEntityDefsModuleInitScriptEnd()
{
	sourcefileBody_ += "\t\t}\n\n";
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKGodot::writeEntityDefsModuleInitDefTypesBegin()
{
	sourcefileBody_ += "\t\tpublic static void initDefTypes()\n";
	sourcefileBody_ += "\t\t{\n";
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKGodot::writeEntityDefsModuleInitDefTypesEnd()
{
	sourcefileBody_ += "\t\t\tforeach(string datatypeStr in EntityDef.datatypes.Keys)\n\t\t\t{\n";
	sourcefileBody_ += "\t\t\t\tDATATYPE_BASE dataType = EntityDef.datatypes[datatypeStr];\n";
	sourcefileBody_ += "\t\t\t\tif(dataType != null)\n\t\t\t\t{\n";
	sourcefileBody_ += "\t\t\t\t\tdataType.bind();\n\t\t\t\t}\n\t\t\t}\n";

	sourcefileBody_ += "\t\t}\n\n";
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKGodot::writeEntityDefsModuleInitDefType(const DataType* pDataType)
{
	uint16 typeID = datatype2id(pDataType->getName());
	if (typeID == 0 || strcmp(pDataType->getName(), "FIXED_DICT") == 0 || strcmp(pDataType->getName(), "ARRAY") == 0)
	{
		typeID = pDataType->id();
		KBE_ASSERT(typeID > datatype2id("KBE_DATATYPE2ID_MAX"));
	}

	static std::map< int, std::string > type2name;

	sourcefileBody_ += fmt::format("\t\t\t{{\n");
	sourcefileBody_ += fmt::format("\t\t\t\tUInt16 utype = {};\n", typeID);

	std::string typeName = (strlen(pDataType->aliasName()) > 0 ? pDataType->aliasName() : fmt::format("AnonymousArray_{}", typeID));
	sourcefileBody_ += fmt::format("\t\t\t\tstring typeName = \"{}\";\n", typeName);

	std::map< int, std::string >::iterator iter = type2name.find(typeID);
	if(iter == type2name.end())
		type2name[typeID] = (strlen(pDataType->getName()) > 0 ? pDataType->getName() : typeName);

	if (strcmp(pDataType->getName(), "FIXED_DICT") == 0)
	{
		sourcefileBody_ += fmt::format("\t\t\t\tDATATYPE_{} datatype = new DATATYPE_{}();\n", typeName, typeName);
		sourcefileBody_ += fmt::format("\t\t\t\tEntityDef.datatypes[typeName] = datatype;\n");
	}
	else if (strcmp(pDataType->getName(), "ARRAY") == 0)
	{
		FixedArrayType* pFixedArrayType = const_cast<FixedArrayType*>(static_cast<const FixedArrayType*>(pDataType));
		typeID = datatype2id(pFixedArrayType->getDataType()->getName());

		if (typeID == 0 || strcmp(pFixedArrayType->getDataType()->getName(), "FIXED_DICT") == 0 ||
			strcmp(pFixedArrayType->getDataType()->getName(), "ARRAY") == 0)
			typeID = pFixedArrayType->getDataType()->id();

		sourcefileBody_ += fmt::format("\t\t\t\tDATATYPE_{} datatype = new DATATYPE_{}();\n", typeName, typeName);
		sourcefileBody_ += fmt::format("\t\t\t\tEntityDef.datatypes[typeName] = datatype;\n");
	}
	else
	{
		sourcefileBody_ += fmt::format("\t\t\t\tstring name = \"{}\";\n", pDataType->getName());
		sourcefileBody_ += fmt::format("\t\t\t\tDATATYPE_BASE val = null;\n");
		sourcefileBody_ += fmt::format("\t\t\t\tEntityDef.datatypes.TryGetValue(name, out val);\n");
		sourcefileBody_ += fmt::format("\t\t\t\tEntityDef.datatypes[typeName] = val;\n");
	}

	sourcefileBody_ += fmt::format("\t\t\t\tEntityDef.id2datatypes[utype] = EntityDef.datatypes[typeName];\n");
	sourcefileBody_ += fmt::format("\t\t\t\tEntityDef.datatype2id[typeName] = utype;\n");
	sourcefileBody_ += fmt::format("\t\t\t}}\n\n");

	return true;
}

//-------------------------------------------------------------------------------------
void ClientSDKGodot::onEntityCallModuleFileName(const std::string& moduleName)
{
	sourcefileName_ = std::string("EntityCall") + moduleName + moduleSuffix + ".gd";
}

//-------------------------------------------------------------------------------------
bool ClientSDKGodot::writeEntityCallBegin(ScriptDefModule* pScriptDefModule)
{
	sourcefileBody_ = headerBody;
	strutil::kbe_replace(sourcefileBody_, "#REPLACE#", fmt::format("\t\n",
		sourcefileName_));

	sourcefileBody_ += "namespace KBEngine\n{\n";
	sourcefileBody_ += "\tusing UnityEngine;\n";
	sourcefileBody_ += "\tusing System;\n";
	sourcefileBody_ += "\tusing System.Collections;\n";
	sourcefileBody_ += "\tusing System.Collections.Generic;\n\n";

	sourcefileBody_ += std::string("\t// defined in */scripts/entity_defs/") + pScriptDefModule->getName() + ".def\n";
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKGodot::writeEntityCallEnd(ScriptDefModule* pScriptDefModule)
{
	sourcefileBody_ += fmt::format("\t}}\n");
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKGodot::writeEntityCallMethodBegin(ScriptDefModule* pScriptDefModule, MethodDescription* pMethodDescription, const char* fillString1, const char* fillString2, COMPONENT_TYPE componentType)
{
	sourcefileBody_ += fmt::format("\t\tpublic void {}({})\n\t\t{{\n", pMethodDescription->getName(), fillString1);

	sourcefileBody_ += fmt::format("\t\t\tBundle pBundle = newCall(\"{}\", {});\n", pMethodDescription->getName(), (pScriptDefModule->isComponentModule() ? "entityComponentPropertyID" : "0"));
	sourcefileBody_ += fmt::format("\t\t\tif(pBundle == null)\n");
	sourcefileBody_ += fmt::format("\t\t\t\treturn;\n\n");

	std::vector<DataType*>& argTypes = pMethodDescription->getArgTypes();
	std::vector<DataType*>::iterator iter = argTypes.begin();

	std::string writeName;

	int i = 1;

	for (; iter != argTypes.end(); ++iter)
	{
		DataType* pDataType = (*iter);

		if (pDataType->type() == DATA_TYPE_FIXEDDICT)
		{
			writeName = fmt::format("((DATATYPE_{})EntityDef.id2datatypes[{}]).addToStreamEx(bundle, arg{})",
				pDataType->aliasName(), pDataType->id(), i);
		}
		else if (pDataType->type() == DATA_TYPE_FIXEDARRAY)
		{
			if (strlen(pDataType->aliasName()) > 0)
			{
				writeName = fmt::format("((DATATYPE_{})EntityDef.id2datatypes[{}]).addToStreamEx(bundle, arg{})",
					pDataType->aliasName(), pDataType->id(), i);
			}
			else
			{
				writeName = fmt::format("((DATATYPE_AnonymousArray_{})EntityDef.id2datatypes[{}]).addToStreamEx(bundle, arg{})",
					pDataType->id(), pDataType->id(), i);
			}
		}
		else
		{
			writeName = datatype2nativetype(pDataType->getName());
			std::transform(writeName.begin(), writeName.end(), writeName.begin(), tolower);
			writeName[0] = std::toupper(writeName[0]);

			writeName = fmt::format("bundle.write{}(arg{})", writeName, i);
		}

		sourcefileBody_ += fmt::format("\t\t\t{};\n", writeName);

		i++;
	}

	sourcefileBody_ += fmt::format("\t\t\tsendCall(null);\n");
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKGodot::writeEntityCallMethodEnd(ScriptDefModule* pScriptDefModule, MethodDescription* pMethodDescription)
{
	sourcefileBody_ += fmt::format("\t\t}}\n\n");
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKGodot::writeBaseEntityCallBegin(ScriptDefModule* pScriptDefModule)
{
	std::string newModuleName;

	newModuleName = std::string("EntityBaseEntityCall_") + std::string(pScriptDefModule->getName()) + moduleSuffix;
	sourcefileBody_ += fmt::format("\tpublic class {} : EntityCall\n\t{{\n", newModuleName);

	if (!pScriptDefModule->isComponentModule())
	{
		std::string initstr = "";

		ScriptDefModule::PROPERTYDESCRIPTION_MAP clientPropertys = pScriptDefModule->getClientPropertyDescriptions();
		ScriptDefModule::PROPERTYDESCRIPTION_MAP::const_iterator propIter = clientPropertys.begin();
		for (; propIter != clientPropertys.end(); ++propIter)
		{
			PropertyDescription* pPropertyDescription = propIter->second;

			if (pPropertyDescription->getDataType()->type() != DATA_TYPE_ENTITY_COMPONENT)
				continue;

			EntityComponentType * pEntityComponentType = (EntityComponentType*)pPropertyDescription->getDataType();

			sourcefileBody_ += fmt::format("\t\tpublic EntityBaseEntityCall_{}{} {} = null;\n",
				pEntityComponentType->pScriptDefModule()->getName(), moduleSuffix, pPropertyDescription->getName());

			initstr += fmt::format("\t\t\t{} = new EntityBaseEntityCall_{}{}({}, id);\n",
				pPropertyDescription->getName(), pEntityComponentType->pScriptDefModule()->getName(), moduleSuffix, pPropertyDescription->getUType());
		}

		sourcefileBody_ += fmt::format("\n\t\tpublic {}(Int32 eid, string ename) : base(eid, ename)\n\t\t{{\n", newModuleName);
		sourcefileBody_ += initstr;
	}
	else
	{
		sourcefileBody_ += fmt::format("\t\tpublic UInt16 entityComponentPropertyID = 0;\n");

		sourcefileBody_ += fmt::format("\n\t\tpublic {}(UInt16 ecpID, Int32 eid) : base(eid, \"{}\")\n\t\t{{\n", newModuleName, pScriptDefModule->getName());
		sourcefileBody_ += fmt::format("\t\t\tentityComponentPropertyID = ecpID;\n");
	}

	sourcefileBody_ += fmt::format("\t\t\ttype = ENTITYCALL_TYPE.ENTITYCALL_TYPE_BASE;\n");
	sourcefileBody_ += fmt::format("\t\t}}\n\n");
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKGodot::writeBaseEntityCallEnd(ScriptDefModule* pScriptDefModule)
{
	sourcefileBody_ += fmt::format("\t}}\n");
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKGodot::writeCellEntityCallBegin(ScriptDefModule* pScriptDefModule)
{
	std::string newModuleName;

	newModuleName = std::string("EntityCellEntityCall_") + std::string(pScriptDefModule->getName()) + moduleSuffix;
	sourcefileBody_ += fmt::format("\tpublic class {} : EntityCall\n\t{{\n", newModuleName);

	if (!pScriptDefModule->isComponentModule())
	{
		std::string initstr = "";

		ScriptDefModule::PROPERTYDESCRIPTION_MAP clientPropertys = pScriptDefModule->getClientPropertyDescriptions();
		ScriptDefModule::PROPERTYDESCRIPTION_MAP::const_iterator propIter = clientPropertys.begin();
		for (; propIter != clientPropertys.end(); ++propIter)
		{
			PropertyDescription* pPropertyDescription = propIter->second;

			if (pPropertyDescription->getDataType()->type() != DATA_TYPE_ENTITY_COMPONENT)
				continue;

			EntityComponentType * pEntityComponentType = (EntityComponentType*)pPropertyDescription->getDataType();

			sourcefileBody_ += fmt::format("\t\tpublic EntityCellEntityCall_{}{} {} = null;\n",
				pEntityComponentType->pScriptDefModule()->getName(), moduleSuffix, pPropertyDescription->getName());

			initstr += fmt::format("\t\t\t{} = new EntityCellEntityCall_{}{}({}, id);\n",
				pPropertyDescription->getName(), pEntityComponentType->pScriptDefModule()->getName(), moduleSuffix, pPropertyDescription->getUType());
		}

		sourcefileBody_ += fmt::format("\n\t\tpublic {}(Int32 eid, string ename) : base(eid, ename)\n\t\t{{\n", newModuleName);
		sourcefileBody_ += initstr;
	}
	else
	{
		sourcefileBody_ += fmt::format("\t\tpublic UInt16 entityComponentPropertyID = 0;\n");

		sourcefileBody_ += fmt::format("\n\t\tpublic {}(UInt16 ecpID, Int32 eid) : base(eid, \"{}\")\n\t\t{{\n", newModuleName, pScriptDefModule->getName());
		sourcefileBody_ += fmt::format("\t\t\tentityComponentPropertyID = ecpID;\n");
		sourcefileBody_ += fmt::format("\t\t\tclassName = \"{}\";\n", pScriptDefModule->getName());
	}

	sourcefileBody_ += fmt::format("\t\t\ttype = ENTITYCALL_TYPE.ENTITYCALL_TYPE_CELL;\n");
	sourcefileBody_ += fmt::format("\t\t}}\n\n");
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKGodot::writeCellEntityCallEnd(ScriptDefModule* pScriptDefModule)
{
	sourcefileBody_ += fmt::format("\t}}\n");
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKGodot::writeCustomDataTypesBegin()
{
	initBody_ = "";
	sourcefileBody_ = headerBody;
	strutil::kbe_replace(sourcefileBody_, "#REPLACE#", "");

	sourcefileBody_ += "namespace KBEngine\n{\n";
	sourcefileBody_ += "\tusing UnityEngine;\n";
	sourcefileBody_ += "\tusing System;\n";
	sourcefileBody_ += "\tusing System.Collections;\n";
	sourcefileBody_ += "\tusing System.Collections.Generic;\n\n";
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKGodot::writeCustomDataTypesEnd()
{
	sourcefileBody_ += "\n}";
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKGodot::createArrayChildClass(DataType* pRootDataType, DataType* pDataType, const std::string& className, const std::string& tabs, int numLayer)
{
	sourcefileBody_ += fmt::format("{}public class DATATYPE_{} : DATATYPE_BASE\n{}{{\n", tabs, className, tabs);

	uint16 typeID = datatype2id(pDataType->getName());
	if (typeID == 0 || strcmp(pDataType->getName(), "FIXED_DICT") == 0 || strcmp(pDataType->getName(), "ARRAY") == 0)
	{
		typeID = pDataType->id();
		KBE_ASSERT(typeID > datatype2id("KBE_DATATYPE2ID_MAX"));
	}

	std::string readName;
	std::string typeName = (strlen(pDataType->aliasName()) > 0 ? pDataType->aliasName() : fmt::format("AnonymousArray_{}", typeID));

	bool isFixedType = strcmp(pDataType->getName(), "FIXED_DICT") == 0 ||
		strcmp(pDataType->getName(), "ARRAY") == 0;

	if (strcmp(pDataType->getName(), "FIXED_DICT") == 0)
	{
		readName = fmt::format("itemType.createFromStreamEx(stream)");

		sourcefileBody_ += fmt::format("{}\tprivate DATATYPE_{} itemType = new DATATYPE_{}();\n\n",
			tabs, pDataType->aliasName(), pDataType->aliasName());

		// 如果是非匿名的数组，则第一层解析应该直接设置为有名字的类别
		// 否则设置为系统List类别
		if (numLayer == 1)
		{
			if (strlen(pRootDataType->aliasName()) == 0 || pRootDataType->aliasName()[0] == '_')
			{
				typeName = fmt::format("List<{}>", typeName);
			}
			else
			{
				typeName = pRootDataType->aliasName();
			}
		}
		else
		{
			typeName = fmt::format("List<{}>", typeName);
		}

		sourcefileBody_ += fmt::format("{}\tpublic {} createFromStreamEx(MemoryStream stream)\n{}\t{{\n", tabs, typeName, tabs);
		sourcefileBody_ += fmt::format("{}\t\tUInt32 size = stream.readUint32();\n", tabs);
		sourcefileBody_ += fmt::format("{}\t\t{} datas = new {}();\n\n", tabs, typeName, typeName);
		sourcefileBody_ += fmt::format("{}\t\twhile(size > 0)\n", tabs);
		sourcefileBody_ += fmt::format("{}\t\t{{\n", tabs);
		sourcefileBody_ += fmt::format("{}\t\t\t--size;\n", tabs);
		sourcefileBody_ += fmt::format("{}\t\t\tdatas.Add({});\n", tabs, readName);
		sourcefileBody_ += fmt::format("{}\t\t}};\n\n", tabs);
		sourcefileBody_ += fmt::format("{}\t\treturn datas;\n", tabs);
		sourcefileBody_ += fmt::format("{}\t}}\n\n", tabs);


		sourcefileBody_ += fmt::format("{}\tpublic void addToStreamEx(Bundle stream, {} v)\n{}\t{{\n", tabs, typeName, tabs);
		sourcefileBody_ += fmt::format("{}\t\tstream.writeUint32((UInt32)v.Count);\n", tabs);
		sourcefileBody_ += fmt::format("{}\t\tfor(int i=0; i<v.Count; ++i)\n", tabs);
		sourcefileBody_ += fmt::format("{}\t\t{{\n", tabs);

		std::string writeName;
		if (isFixedType)
		{
			writeName = fmt::format("itemType.addToStreamEx(stream, v[i])");
		}
		else
		{
			writeName = datatype2nativetype(pDataType->getName());
			std::transform(writeName.begin(), writeName.end(), writeName.begin(), tolower);
			writeName[0] = std::toupper(writeName[0]);
			writeName = fmt::format("stream.write{}(v[i])", writeName);
		}

		sourcefileBody_ += fmt::format("{}\t\t\t{};\n", tabs, writeName);
		sourcefileBody_ += fmt::format("{}\t\t}};\n", tabs);
		sourcefileBody_ += fmt::format("{}\t}}\n", tabs);
	}
	else if (strcmp(pDataType->getName(), "ARRAY") == 0)
	{
		FixedArrayType* pFixedArrayType = static_cast<FixedArrayType*>(pDataType);

		std::string classNameStr = typeName;

		// 如果是非匿名的数组，则第一层解析应该直接设置为有名字的类别
		// 否则设置为系统List类别
		if (numLayer == 1)
		{
			if (strlen(pRootDataType->aliasName()) == 0 || pRootDataType->aliasName()[0] == '_')
			{
				typeName = "";
				getArrayType(pFixedArrayType, typeName);
				typeName = fmt::format("List<{}>", typeName);
			}
			else
			{
				typeName = pRootDataType->aliasName();
			}
		}
		else
		{
			typeName = "";
			getArrayType(pFixedArrayType, typeName);
			typeName = fmt::format("List<{}>", typeName);
		}

		readName = fmt::format("itemType.createFromStreamEx(stream)");

		std::string childClassName = classNameStr + "_ChildArray";
		sourcefileBody_ += fmt::format("{}\tprivate DATATYPE_{} itemType = new DATATYPE_{}();\n\n",
			tabs, childClassName, childClassName);

		if (!createArrayChildClass(pRootDataType, pFixedArrayType->getDataType(), childClassName, tabs + "\t", numLayer + 1))
			return false;

		sourcefileBody_ += fmt::format("{}\tpublic {} createFromStreamEx(MemoryStream stream)\n{}\t{{\n", tabs, typeName, tabs);
		sourcefileBody_ += fmt::format("{}\t\tUInt32 size = stream.readUint32();\n", tabs);
		sourcefileBody_ += fmt::format("{}\t\t{} datas = new {}();\n\n", tabs, typeName, typeName);
		sourcefileBody_ += fmt::format("{}\t\twhile(size > 0)\n", tabs);
		sourcefileBody_ += fmt::format("{}\t\t{{\n", tabs);
		sourcefileBody_ += fmt::format("{}\t\t\t--size;\n", tabs);
		sourcefileBody_ += fmt::format("{}\t\t\tdatas.Add({});\n", tabs, readName);
		sourcefileBody_ += fmt::format("{}\t\t}};\n\n", tabs);
		sourcefileBody_ += fmt::format("{}\t\treturn datas;\n", tabs);
		sourcefileBody_ += fmt::format("{}\t}}\n\n", tabs);


		sourcefileBody_ += fmt::format("{}\tpublic void addToStreamEx(Bundle stream, {} v)\n{}\t{{\n", tabs, typeName, tabs);
		sourcefileBody_ += fmt::format("{}\t\tstream.writeUint32((UInt32)v.Count);\n", tabs);
		sourcefileBody_ += fmt::format("{}\t\tfor(int i=0; i<v.Count; ++i)\n", tabs);
		sourcefileBody_ += fmt::format("{}\t\t{{\n", tabs);

		std::string writeName;
		if (isFixedType)
		{
			writeName = fmt::format("itemType.addToStreamEx(stream, v[i])", writeName);
		}
		else
		{
			writeName = datatype2nativetype(pDataType->getName());
			std::transform(writeName.begin(), writeName.end(), writeName.begin(), tolower);
			writeName[0] = std::toupper(writeName[0]);
			writeName = fmt::format("stream.write{}(v[i])", writeName);
		}

		sourcefileBody_ += fmt::format("{}\t\t\t{};\n", tabs, writeName);
		sourcefileBody_ += fmt::format("{}\t\t}};\n", tabs);
		sourcefileBody_ += fmt::format("{}\t}}\n", tabs);
	}
	else
	{
		readName = datatype2nativetype(pDataType->getName());
		typeName = "var";
		std::transform(readName.begin(), readName.end(), readName.begin(), tolower);
		readName[0] = std::toupper(readName[0]);
		readName = fmt::format("stream.read{}()", readName);

		sourcefileBody_ += fmt::format("{}\tpublic List<{}> createFromStreamEx(MemoryStream stream)\n{}\t{{\n", tabs, typeName, tabs);
		sourcefileBody_ += fmt::format("{}\t\tUInt32 size = stream.readUint32();\n", tabs);
		sourcefileBody_ += fmt::format("{}\t\tList<{}> datas = new List<{}>();\n\n", tabs, typeName, typeName);
		sourcefileBody_ += fmt::format("{}\t\twhile(size > 0)\n", tabs);
		sourcefileBody_ += fmt::format("{}\t\t{{\n", tabs);
		sourcefileBody_ += fmt::format("{}\t\t\t--size;\n", tabs);
		sourcefileBody_ += fmt::format("{}\t\t\tdatas.Add({});\n", tabs, readName);
		sourcefileBody_ += fmt::format("{}\t\t}};\n\n", tabs);
		sourcefileBody_ += fmt::format("{}\t\treturn datas;\n", tabs);
		sourcefileBody_ += fmt::format("{}\t}}\n\n", tabs);

		sourcefileBody_ += fmt::format("{}\tpublic void addToStreamEx(Bundle stream, List<{}> v)\n{}\t{{\n", tabs, typeName, tabs);
		sourcefileBody_ += fmt::format("{}\t\tstream.writeUint32((UInt32)v.Count);\n", tabs);
		sourcefileBody_ += fmt::format("{}\t\tfor(int i=0; i<v.Count; ++i)\n", tabs);
		sourcefileBody_ += fmt::format("{}\t\t{{\n", tabs);

		std::string writeName;
		writeName = datatype2nativetype(pDataType->getName());
		std::transform(writeName.begin(), writeName.end(), writeName.begin(), tolower);
		writeName[0] = std::toupper(writeName[0]);
		writeName = fmt::format("stream.write{}(v[i])", writeName);

		sourcefileBody_ += fmt::format("{}\t\t\t{};\n", tabs, writeName);
		sourcefileBody_ += fmt::format("{}\t\t}};\n", tabs);
		sourcefileBody_ += fmt::format("{}\t}}\n", tabs);
	}

	sourcefileBody_ += fmt::format("{}}}\n\n", tabs);
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKGodot::writeCustomDataType(const DataType* pDataType)
{
	uint16 typeID = datatype2id(pDataType->getName());
	if (typeID == 0 || strcmp(pDataType->getName(), "FIXED_DICT") == 0 || strcmp(pDataType->getName(), "ARRAY") == 0)
	{
		typeID = pDataType->id();
		KBE_ASSERT(typeID > datatype2id("KBE_DATATYPE2ID_MAX"));
	}

	static std::map< int, std::string > type2name;

	std::string typeName = (strlen(pDataType->aliasName()) > 0 ? pDataType->aliasName() : fmt::format("AnonymousArray_{}", typeID));

	std::map< int, std::string >::iterator iter = type2name.find(typeID);
	if (iter == type2name.end())
		type2name[typeID] = (strlen(pDataType->getName()) > 0 ? pDataType->getName() : typeName);

	if (strcmp(pDataType->getName(), "FIXED_DICT") == 0)
	{
		sourcefileBody_ += fmt::format("\n\n\tpublic class DATATYPE_{} : DATATYPE_BASE\n\t{{\n", typeName);

		FixedDictType* dictdatatype = const_cast<FixedDictType*>(static_cast<const FixedDictType*>(pDataType));

		// 先创建属性
		{
			FixedDictType::FIXEDDICT_KEYTYPE_MAP& keys = dictdatatype->getKeyTypes();
			FixedDictType::FIXEDDICT_KEYTYPE_MAP::const_iterator keyiter = keys.begin();
			for (; keyiter != keys.end(); ++keyiter)
			{
				DataType* pKeyDataType = keyiter->second->dataType;
				if (strcmp(pKeyDataType->getName(), "FIXED_DICT") == 0)
				{
					sourcefileBody_ += fmt::format("\t\tprivate DATATYPE_{} {}_DataType = new DATATYPE_{}();\n",
						pKeyDataType->aliasName(), keyiter->first, pKeyDataType->aliasName());
				}
				else if (strcmp(pKeyDataType->getName(), "ARRAY") == 0)
				{
					FixedArrayType* pFixedArrayType = const_cast<FixedArrayType*>(static_cast<const FixedArrayType*>(pKeyDataType));

					std::string className = pKeyDataType->aliasName();

					sourcefileBody_ += fmt::format("\t\tprivate DATATYPE_{} {}_DataType = new DATATYPE_{}();\n\n",
						className + "_ChildArray", keyiter->first, className + "_ChildArray");

					createArrayChildClass(pFixedArrayType, pFixedArrayType->getDataType(), className + "_ChildArray", "\t\t");
				}
				else
				{
				}
			}
		}

		// 创建createFromStreamEx方法
		{
			sourcefileBody_ += fmt::format("\t\tpublic {} createFromStreamEx(MemoryStream stream)\n\t\t{{\n", typeName);

			sourcefileBody_ += fmt::format("\t\t\t{} datas = new {}();\n", typeName, typeName);

			FixedDictType::FIXEDDICT_KEYTYPE_MAP& keys = dictdatatype->getKeyTypes();
			FixedDictType::FIXEDDICT_KEYTYPE_MAP::const_iterator keyiter = keys.begin();
			for (; keyiter != keys.end(); ++keyiter)
			{
				DataType* pKeyDataType = keyiter->second->dataType;
				if (strcmp(pKeyDataType->getName(), "FIXED_DICT") == 0)
				{
					sourcefileBody_ += fmt::format("\t\t\tdatas.{} = {}_DataType.createFromStreamEx(stream);\n", keyiter->first, keyiter->first);
				}
				else if (strcmp(pKeyDataType->getName(), "ARRAY") == 0)
				{
					sourcefileBody_ += fmt::format("\t\t\tdatas.{} = {}_DataType.createFromStreamEx(stream);\n", keyiter->first, keyiter->first);
				}
				else
				{
					std::string readName = datatype2nativetype(pKeyDataType->getName());
					std::transform(readName.begin(), readName.end(), readName.begin(), tolower);
					readName[0] = std::toupper(readName[0]);
					readName = fmt::format("stream.read{}()", readName);

					sourcefileBody_ += fmt::format("\t\t\tdatas.{} = {};\n", keyiter->first, readName);
				}
			}

			sourcefileBody_ += fmt::format("\t\t\treturn datas;\n");
			sourcefileBody_ += fmt::format("\t\t}}\n\n");
		}

		// 创建addToStreamEx方法
		{
			sourcefileBody_ += fmt::format("\t\tpublic void addToStreamEx(Bundle stream, {} v)\n\t\t{{\n", typeName);

			FixedDictType::FIXEDDICT_KEYTYPE_MAP& keys = dictdatatype->getKeyTypes();
			FixedDictType::FIXEDDICT_KEYTYPE_MAP::const_iterator keyiter = keys.begin();
			for (; keyiter != keys.end(); ++keyiter)
			{
				DataType* pKeyDataType = keyiter->second->dataType;
				if (strcmp(pKeyDataType->getName(), "FIXED_DICT") == 0)
				{
					sourcefileBody_ += fmt::format("\t\t\t{}_DataType.addToStreamEx(stream, v.{});\n", keyiter->first, keyiter->first);
				}
				else if (strcmp(pKeyDataType->getName(), "ARRAY") == 0)
				{
					sourcefileBody_ += fmt::format("\t\t\t{}_DataType.addToStreamEx(stream, v.{});\n", keyiter->first, keyiter->first);
				}
				else
				{
					std::string writeName = datatype2nativetype(pKeyDataType->getName());
					std::transform(writeName.begin(), writeName.end(), writeName.begin(), tolower);
					writeName[0] = std::toupper(writeName[0]);

					sourcefileBody_ += fmt::format("\t\t\tstream.write{}(v.{});\n", writeName, keyiter->first);
				}
			}

			sourcefileBody_ += fmt::format("\t\t}}\n");
		}

		sourcefileBody_ += fmt::format("\t}}\n\n");

	}
	else if (strcmp(pDataType->getName(), "ARRAY") == 0)
	{
		FixedArrayType* pFixedArrayType = const_cast<FixedArrayType*>(static_cast<const FixedArrayType*>(pDataType));
		typeID = datatype2id(pFixedArrayType->getDataType()->getName());

		if (typeID == 0 || strcmp(pFixedArrayType->getDataType()->getName(), "FIXED_DICT") == 0 ||
			strcmp(pFixedArrayType->getDataType()->getName(), "ARRAY") == 0)
			typeID = pFixedArrayType->getDataType()->id();

		std::string itemTypeName = "var";
		if (itemTypeName == "")
		{
			itemTypeName = pFixedArrayType->getDataType()->aliasName();
		}

		std::string className = typeName;

		if (strlen(pFixedArrayType->aliasName()) == 0 || pFixedArrayType->aliasName()[0] == '_')
		{
			typeName = "";
			getArrayType(pFixedArrayType, typeName);
		}

		std::string readName;
		sourcefileBody_ += fmt::format("\n\n\tpublic class DATATYPE_{} : DATATYPE_BASE\n\t{{\n", className);

		bool isFixedType = strcmp(pFixedArrayType->getDataType()->getName(), "FIXED_DICT") == 0 ||
		strcmp(pFixedArrayType->getDataType()->getName(), "ARRAY") == 0;

		if (strcmp(pFixedArrayType->getDataType()->getName(), "FIXED_DICT") == 0)
		{
			readName = fmt::format("itemType.createFromStreamEx(stream)", readName);

			sourcefileBody_ += fmt::format("\t\tprivate DATATYPE_{} itemType = new DATATYPE_{}();\n\n",
			pFixedArrayType->getDataType()->aliasName(), pFixedArrayType->getDataType()->aliasName());

			sourcefileBody_ += fmt::format("\t\tpublic {} createFromStreamEx(MemoryStream stream)\n\t\t{{\n", typeName);
			sourcefileBody_ += fmt::format("\t\t\tUInt32 size = stream.readUint32();\n");
			sourcefileBody_ += fmt::format("\t\t\t{} datas = new {}();\n\n", typeName, typeName);
			sourcefileBody_ += fmt::format("\t\t\twhile(size > 0)\n");
			sourcefileBody_ += fmt::format("\t\t\t{{\n");
			sourcefileBody_ += fmt::format("\t\t\t\t--size;\n");
			sourcefileBody_ += fmt::format("\t\t\t\tdatas.Add({});\n", readName);
			sourcefileBody_ += fmt::format("\t\t\t}};\n\n");
			sourcefileBody_ += fmt::format("\t\t\treturn datas;\n");
			sourcefileBody_ += fmt::format("\t\t}}\n\n");

			sourcefileBody_ += fmt::format("\t\tpublic void addToStreamEx(Bundle stream, {} v)\n\t\t{{\n", typeName);
			sourcefileBody_ += fmt::format("\t\t\tstream.writeUint32((UInt32)v.Count);\n");
			sourcefileBody_ += fmt::format("\t\t\tfor(int i=0; i<v.Count; ++i)\n");
			sourcefileBody_ += fmt::format("\t\t\t{{\n");

			std::string writeName;
			if (isFixedType)
			{
				writeName = fmt::format("itemType.addToStreamEx(stream, v[i])", writeName);
			}
			else
			{
				writeName = datatype2nativetype(pFixedArrayType->getDataType()->getName());
				std::transform(writeName.begin(), writeName.end(), writeName.begin(), tolower);
				writeName[0] = std::toupper(writeName[0]);
				writeName = fmt::format("stream.write{}(v[i])", writeName);
			}

			sourcefileBody_ += fmt::format("\t\t\t\t{};\n", writeName);
			sourcefileBody_ += fmt::format("\t\t\t}};\n");
			sourcefileBody_ += fmt::format("\t\t}}\n");

			sourcefileBody_ += fmt::format("\t}}\n\n");
		}
		else if (strcmp(pFixedArrayType->getDataType()->getName(), "ARRAY") == 0)
		{
			readName = fmt::format("itemType.createFromStreamEx(stream)", readName);

			sourcefileBody_ += fmt::format("\t\tprivate DATATYPE_{} itemType = new DATATYPE_{}();\n\n",
				className + "_ChildArray", className + "_ChildArray");

			createArrayChildClass(pFixedArrayType, pFixedArrayType->getDataType(), className + "_ChildArray", "\t\t");

			sourcefileBody_ += fmt::format("\t\tpublic {} createFromStreamEx(MemoryStream stream)\n\t\t{{\n", typeName);
			sourcefileBody_ += fmt::format("\t\t\treturn {};\n", readName);
			sourcefileBody_ += fmt::format("\t\t}}\n\n");

			sourcefileBody_ += fmt::format("\t\tpublic void addToStreamEx(Bundle stream, {} v)\n\t\t{{\n", typeName);
			std::string writeName = fmt::format("itemType.addToStreamEx(stream, v)", writeName);
			sourcefileBody_ += fmt::format("\t\t\t{};\n", writeName);
			sourcefileBody_ += fmt::format("\t\t}}\n");

			sourcefileBody_ += fmt::format("\t}}\n\n");
		}
		else
		{
			readName = datatype2nativetype(pFixedArrayType->getDataType()->getName());
			std::transform(readName.begin(), readName.end(), readName.begin(), tolower);
			readName[0] = std::toupper(readName[0]);
			readName = fmt::format("stream.read{}()", readName);

			sourcefileBody_ += fmt::format("\t\tpublic {} createFromStreamEx(MemoryStream stream)\n\t\t{{\n", typeName);
			sourcefileBody_ += fmt::format("\t\t\tUInt32 size = stream.readUint32();\n");
			sourcefileBody_ += fmt::format("\t\t\t{} datas = new {}();\n\n", typeName, typeName);
			sourcefileBody_ += fmt::format("\t\t\twhile(size > 0)\n");
			sourcefileBody_ += fmt::format("\t\t\t{{\n");
			sourcefileBody_ += fmt::format("\t\t\t\t--size;\n");
			sourcefileBody_ += fmt::format("\t\t\t\tdatas.Add({});\n", readName);
			sourcefileBody_ += fmt::format("\t\t\t}};\n\n");
			sourcefileBody_ += fmt::format("\t\t\treturn datas;\n");
			sourcefileBody_ += fmt::format("\t\t}}\n\n");

			sourcefileBody_ += fmt::format("\t\tpublic void addToStreamEx(Bundle stream, {} v)\n\t\t{{\n", typeName);
			sourcefileBody_ += fmt::format("\t\t\tstream.writeUint32((UInt32)v.Count);\n");
			sourcefileBody_ += fmt::format("\t\t\tfor(int i=0; i<v.Count; ++i)\n");
			sourcefileBody_ += fmt::format("\t\t\t{{\n");

			std::string writeName;
			if (isFixedType)
			{
				writeName = fmt::format("itemType.addToStreamEx(stream, v[i])", writeName);
			}
			else
			{
				writeName = datatype2nativetype(pFixedArrayType->getDataType()->getName());
				std::transform(writeName.begin(), writeName.end(), writeName.begin(), tolower);
				writeName[0] = std::toupper(writeName[0]);
				writeName = fmt::format("stream.write{}(v[i])", writeName);
			}

			sourcefileBody_ += fmt::format("\t\t\t\t{};\n", writeName);
			sourcefileBody_ += fmt::format("\t\t\t}};\n");
			sourcefileBody_ += fmt::format("\t\t}}\n");

			sourcefileBody_ += fmt::format("\t}}\n\n");
		}
	}
	else
	{
	}

	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKGodot::writeEntityDefsModuleInitScript_ScriptModule(ScriptDefModule* pScriptDefModule)
{
	sourcefileBody_ += fmt::format("\t\t\tScriptModule p{}Module = new ScriptModule(\"{}\");\n", pScriptDefModule->getName(), pScriptDefModule->getName());
	sourcefileBody_ += fmt::format("\t\t\tEntityDef.moduledefs[\"{}\"] = p{}Module;\n", pScriptDefModule->getName(), pScriptDefModule->getName());
	sourcefileBody_ += fmt::format("\t\t\tEntityDef.idmoduledefs[{}] = p{}Module;\n\n", pScriptDefModule->getUType(), pScriptDefModule->getName());
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKGodot::writeEntityDefsModuleInitScript_MethodDescr(ScriptDefModule* pScriptDefModule, MethodDescription* pDescr, COMPONENT_TYPE componentType)
{
	sourcefileBody_ += fmt::format("\t\t\tList<DATATYPE_BASE> p{}_{}_args = new List<DATATYPE_BASE>();\n", pScriptDefModule->getName(), pDescr->getName());

	const std::vector<DataType*>& args = pDescr->getArgTypes();
	std::vector<DataType*>::const_iterator argiter = args.begin();
	for (; argiter != args.end(); ++argiter)
	{
		uint16 typeID = datatype2id((*argiter)->getName());
		if (typeID == 0 || strcmp((*argiter)->getName(), "FIXED_DICT") == 0 || strcmp((*argiter)->getName(), "ARRAY") == 0)
			typeID = (*argiter)->id();

		sourcefileBody_ += fmt::format("\t\t\tp{}_{}_args.Add(EntityDef.id2datatypes[{}]);\n", pScriptDefModule->getName(), pDescr->getName(), typeID);
	}

	sourcefileBody_ += fmt::format("\n\t\t\tMethod p{}_{} = new Method();\n", pScriptDefModule->getName(), pDescr->getName());
	sourcefileBody_ += fmt::format("\t\t\tp{}_{}.name = \"{}\";\n", pScriptDefModule->getName(), pDescr->getName(), pDescr->getName());
	sourcefileBody_ += fmt::format("\t\t\tp{}_{}.methodUtype = {};\n", pScriptDefModule->getName(), pDescr->getName(), pDescr->getUType());
	sourcefileBody_ += fmt::format("\t\t\tp{}_{}.aliasID = {};\n", pScriptDefModule->getName(), pDescr->getName(), pDescr->aliasID());
	sourcefileBody_ += fmt::format("\t\t\tp{}_{}.args = p{}_{}_args;\n\n", pScriptDefModule->getName(), pDescr->getName(), pScriptDefModule->getName(), pDescr->getName());

	sourcefileBody_ += fmt::format("\t\t\tp{}Module.methods[\"{}\"] = p{}_{}; \n",
		pScriptDefModule->getName(), pDescr->getName(), pScriptDefModule->getName(), pDescr->getName());

	if (pDescr->aliasID() != -1)
	{
		if (componentType == CLIENT_TYPE)
		{
			sourcefileBody_ += fmt::format("\t\t\tp{}Module.useMethodDescrAlias = true;\n", pScriptDefModule->getName());
			sourcefileBody_ += fmt::format("\t\t\tp{}Module.idmethods[(UInt16)p{}_{}.aliasID] = p{}_{};\n\n",
				pScriptDefModule->getName(), pScriptDefModule->getName(), pDescr->getName(), pScriptDefModule->getName(), pDescr->getName());
		}
		else
		{
			KBE_ASSERT(false);
		}
	}
	else
	{
		if (componentType == CLIENT_TYPE)
		{
			sourcefileBody_ += fmt::format("\t\t\tp{}Module.useMethodDescrAlias = false;\n", pScriptDefModule->getName());
			sourcefileBody_ += fmt::format("\t\t\tp{}Module.idmethods[p{}_{}.methodUtype] = p{}_{};\n\n",
				pScriptDefModule->getName(), pScriptDefModule->getName(), pDescr->getName(), pScriptDefModule->getName(), pDescr->getName());
		} 
		if (componentType == BASEAPP_TYPE)
		{
			sourcefileBody_ += fmt::format("\t\t\tp{}Module.base_methods[\"{}\"] = p{}_{};\n\n",
				pScriptDefModule->getName(), pDescr->getName(), pScriptDefModule->getName(), pDescr->getName());

			sourcefileBody_ += fmt::format("\t\t\tp{}Module.idbase_methods[p{}_{}.methodUtype] = p{}_{};\n\n",
				pScriptDefModule->getName(), pScriptDefModule->getName(), pDescr->getName(), pScriptDefModule->getName(), pDescr->getName());
		}
		else
		{
			sourcefileBody_ += fmt::format("\t\t\tp{}Module.cell_methods[\"{}\"] = p{}_{};\n\n",
				pScriptDefModule->getName(), pDescr->getName(), pScriptDefModule->getName(), pDescr->getName());

			sourcefileBody_ += fmt::format("\t\t\tp{}Module.idcell_methods[p{}_{}.methodUtype] = p{}_{};\n\n",
				pScriptDefModule->getName(), pScriptDefModule->getName(), pDescr->getName(), pScriptDefModule->getName(), pDescr->getName());
		}
	}

	sourcefileBody_ += fmt::format("\t\t\t//Dbg.DEBUG_MSG(\"EntityDef::initScriptModules: add({}), method({} / {}).\");\n\n",
		pScriptDefModule->getName(), pDescr->getName(), pDescr->getUType());

	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKGodot::writeEntityDefsModuleInitScript_PropertyDescr(ScriptDefModule* pScriptDefModule, PropertyDescription* pDescr)
{
	uint16 typeID = datatype2id(pDescr->getDataType()->getName());
	bool isFixedType = strcmp(pDescr->getDataType()->getName(), "FIXED_DICT") == 0 || strcmp(pDescr->getDataType()->getName(), "ARRAY") == 0;

	if (typeID == 0 || isFixedType)
		typeID = pDescr->getDataType()->id();

	sourcefileBody_ += fmt::format("\t\t\tProperty p{}_{} = new Property();\n", pScriptDefModule->getName(), pDescr->getName());
	sourcefileBody_ += fmt::format("\t\t\tp{}_{}.name = \"{}\";\n", pScriptDefModule->getName(), pDescr->getName(), pDescr->getName());
	sourcefileBody_ += fmt::format("\t\t\tp{}_{}.properUtype = {};\n", pScriptDefModule->getName(), pDescr->getName(), pDescr->getUType());
	sourcefileBody_ += fmt::format("\t\t\tp{}_{}.properFlags = {};\n", pScriptDefModule->getName(), pDescr->getName(), pDescr->getFlags());
	sourcefileBody_ += fmt::format("\t\t\tp{}_{}.aliasID = {};\n", pScriptDefModule->getName(), pDescr->getName(), pDescr->aliasID());

	if (isFixedType)
	{
		sourcefileBody_ += fmt::format("\t\t\tp{}_{}.defaultVal = EntityDef.id2datatypes[{}].parseDefaultValStr(\"{}\");\n",
			pScriptDefModule->getName(), pDescr->getName(), typeID, pDescr->getDefaultValStr());
	}
	else
	{
		std::string readName = "var";

		if (readName == "Vector2" || readName == "Vector3" || readName == "Vector4")
		{
			sourcefileBody_ += fmt::format("\t\t\t{} {}_{}_defval = new {}();\n", readName, pScriptDefModule->getName(),
				pDescr->getName(), readName);
		}
		else if (readName == "string")
		{
			sourcefileBody_ += fmt::format("\t\t\t{} {}_{}_defval = \"\";\n", readName, pScriptDefModule->getName(),
				pDescr->getName());
		}
		else if (readName == "PYTHON" || readName == "PY_DICT" || readName == "PY_TUPLE" || readName == "PY_LIST" || readName == "byte[]")
		{
			sourcefileBody_ += fmt::format("\t\t\tbyte[] {}_{}_defval = new byte[0];\n", pScriptDefModule->getName(),
				pDescr->getName());
		}
		else if (pDescr->getDataType()->type() == DATA_TYPE_ENTITY_COMPONENT)
		{
		}
		else
		{
			sourcefileBody_ += fmt::format("\t\t\t{} {}_{}_defval;\n\t\t\t{}.TryParse(\"{}\", out {}_{}_defval);\n", readName, pScriptDefModule->getName(),
				pDescr->getName(), readName, pDescr->getDefaultValStr(), pScriptDefModule->getName(), pDescr->getName());
		}

		if (pDescr->getDataType()->type() != DATA_TYPE_ENTITY_COMPONENT)
			sourcefileBody_ += fmt::format("\t\t\tp{}_{}.defaultVal = {}_{}_defval;\n", pScriptDefModule->getName(), pDescr->getName(), pScriptDefModule->getName(), pDescr->getName());
	}

	sourcefileBody_ += fmt::format("\t\t\tp{}Module.propertys[\"{}\"] = p{}_{}; \n\n", 
		pScriptDefModule->getName(), pDescr->getName(), pScriptDefModule->getName(), pDescr->getName());

	if (pDescr->aliasID() != -1)
	{
		sourcefileBody_ += fmt::format("\t\t\tp{}Module.usePropertyDescrAlias = true;\n", pScriptDefModule->getName());
		sourcefileBody_ += fmt::format("\t\t\tp{}Module.idpropertys[(UInt16)p{}_{}.aliasID] = p{}_{};\n\n",
			pScriptDefModule->getName(), pScriptDefModule->getName(), pDescr->getName(), pScriptDefModule->getName(), pDescr->getName());
	}
	else
	{
		sourcefileBody_ += fmt::format("\t\t\tp{}Module.usePropertyDescrAlias = false;\n", pScriptDefModule->getName());
		sourcefileBody_ += fmt::format("\t\t\tp{}Module.idpropertys[p{}_{}.properUtype] = p{}_{};\n\n",
			pScriptDefModule->getName(), pScriptDefModule->getName(), pDescr->getName(), pScriptDefModule->getName(), pDescr->getName());
	}

	sourcefileBody_ += fmt::format("\t\t\t//Dbg.DEBUG_MSG(\"EntityDef::initScriptModules: add({}), property({} / {}).\");\n\n",
		pScriptDefModule->getName(), pDescr->getName(), pDescr->getUType());

	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKGodot::writeTypesBegin()
{
	sourcefileBody_ = headerBody;
	strutil::kbe_replace(sourcefileBody_, "#REPLACE#", "");

	sourcefileBody_ += "namespace KBEngine\n{\n";
	sourcefileBody_ += "\tusing UnityEngine;\n";
	sourcefileBody_ += "\tusing System;\n";
	sourcefileBody_ += "\tusing System.Collections;\n";
	sourcefileBody_ += "\tusing System.Collections.Generic;\n\n";

	sourcefileBody_ += "\n\n\t// defined in */scripts/entity_defs/types.xml\n\n";
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKGodot::writeTypesEnd()
{
	sourcefileBody_ += "\n}";
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKGodot::writeTypeBegin(std::string typeName, FixedDictType* pDataType)
{
	sourcefileBody_ += fmt::format("\tpublic class {}\n\t{{\n", typeName);
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKGodot::writeTypeEnd(std::string typeName, FixedDictType* pDataType)
{
	sourcefileBody_ += "\n\t}\n\n";
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKGodot::writeTypeBegin(std::string typeName, FixedArrayType* pDataType, const std::string& parentClass)
{
	sourcefileBody_ += fmt::format("\tpublic class {}{}\n\t{{\n", typeName, (parentClass.size() > 0 ? std::string(" : ") + parentClass : ""));
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKGodot::writeTypeEnd(std::string typeName, FixedArrayType* pDataType)
{
	sourcefileBody_ += "\n\t}\n\n";
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKGodot::writeTypeBegin(std::string typeName, DataType* pDataType)
{
	sourcefileBody_ += fmt::format("\tpublic struct {}\n\t{{\n", typeName);
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKGodot::writeTypeEnd(std::string typeName, DataType* pDataType)
{
	sourcefileBody_ += "\t}\n\n";
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKGodot::writeTypeItemType_AliasName(const std::string& itemName, const std::string& childItemName)
{
	if (childItemName == "UINT8" || childItemName == "UINT16" || childItemName == "UINT32" || childItemName == "UINT64" || 
		childItemName == "INT8" || childItemName == "INT16" || childItemName == "INT32" || childItemName == "INT64" || 
		childItemName == "FLOAT" || childItemName == "DOUBLE")
	{
		std::string ntype = "var";
		sourcefileBody_ += fmt::format("\t\t{} value;\n\n", ntype);
		sourcefileBody_ += fmt::format("\t\t{}({} value)\n\t\t{{\n", itemName, ntype);
		sourcefileBody_ += fmt::format("\t\t\tthis.value = value;\n\t\t}}\n\n");

		sourcefileBody_ += fmt::format("\t\tpublic static implicit operator {}({} value)\n\t\t{{\n", ntype, itemName);
		sourcefileBody_ += fmt::format("\t\t\treturn value.value;\n\t\t}}\n\n");

		sourcefileBody_ += fmt::format("\t\tpublic static implicit operator {}(int value)\n\t\t{{\n", itemName);
		sourcefileBody_ += fmt::format("\t\t\t{} tvalue = ({})value;\n\t\t\treturn new {}(tvalue);\n\t\t}}\n\n", ntype, ntype, itemName);

		sourcefileBody_ += fmt::format("\t\tpublic static {} MaxValue\n\t\t{{\n", ntype);
		sourcefileBody_ += fmt::format("\t\t\tget\n\t\t\t{{\n\t\t\t\treturn {}.MaxValue;\n\t\t\t}}\n\t\t}}\n\n", ntype);

		sourcefileBody_ += fmt::format("\t\tpublic static {} MinValue\n\t\t{{\n", ntype);
		sourcefileBody_ += fmt::format("\t\t\tget\n\t\t\t{{\n\t\t\t\treturn {}.MinValue;\n\t\t\t}}\n\t\t}}\n", ntype);
	}
	else if (childItemName == "STRING" || childItemName == "UNICODE")
	{
		std::string ntype = "var";
		sourcefileBody_ += fmt::format("\t\t{} value;\n\n", ntype);
		sourcefileBody_ += fmt::format("\t\t{}({} value)\n\t\t{{\n", itemName, ntype);
		sourcefileBody_ += fmt::format("\t\t\tthis.value = value;\n\t\t}}\n\n");

		sourcefileBody_ += fmt::format("\t\tpublic static implicit operator {}({} value)\n\t\t{{\n", ntype, itemName);
		sourcefileBody_ += fmt::format("\t\t\treturn value.value;\n\t\t}}\n\n");

		sourcefileBody_ += fmt::format("\t\tpublic static implicit operator {}({} value)\n\t\t{{\n", itemName, ntype);
		sourcefileBody_ += fmt::format("\t\t\t{} tvalue = ({})value;\n\t\t\treturn new {}(tvalue);\n\t\t}}\n", ntype, ntype, itemName);
	}
	else if (childItemName == "PYTHON" || childItemName == "PY_DICT" || childItemName == "PY_TUPLE" || 
		childItemName == "PY_LIST" || childItemName == "ENTITYCALL" || childItemName == "BLOB")
	{
		std::string ntype = "byte[]";
		sourcefileBody_ += fmt::format("\t\t{} value;\n\n", ntype);
		sourcefileBody_ += fmt::format("\t\t{}({} value)\n\t\t{{\n", itemName, ntype);
		sourcefileBody_ += fmt::format("\t\t\tthis.value = value;\n\t\t}}\n\n");

		sourcefileBody_ += fmt::format("\t\tpublic static implicit operator {}({} value)\n\t\t{{\n", ntype, itemName);
		sourcefileBody_ += fmt::format("\t\t\treturn value.value;\n\t\t}}\n\n");

		sourcefileBody_ += fmt::format("\t\tpublic static implicit operator {}(byte[] value)\n\t\t{{\n", itemName);
		sourcefileBody_ += fmt::format("\t\t\t{} tvalue = ({})value;\n\t\t\treturn new {}(tvalue);\n\t\t}}\n\n", ntype, ntype, itemName);

		sourcefileBody_ += fmt::format("\t\tpublic Byte this[int ID]\n\t\t{{\n");
		sourcefileBody_ += fmt::format("\t\t\tget {{ return value[ID]; }}\n\t\t\tset {{ this.value[ID] = value; }}\n\t\t}}\n");
	}
	else if (childItemName == "VECTOR2" || childItemName == "VECTOR3" || childItemName == "VECTOR4")
	{
		std::string ntype = "var";
		sourcefileBody_ += fmt::format("\t\t{} value;\n\n", ntype);
		sourcefileBody_ += fmt::format("\t\t{}({} value)\n\t\t{{\n", itemName, ntype);
		sourcefileBody_ += fmt::format("\t\t\tthis.value = value;\n\t\t}}\n\n");

		sourcefileBody_ += fmt::format("\t\tpublic static implicit operator {}({} value)\n\t\t{{\n", ntype, itemName);
		sourcefileBody_ += fmt::format("\t\t\treturn value.value;\n\t\t}}\n\n");

		sourcefileBody_ += fmt::format("\t\tpublic static implicit operator {}({} value)\n\t\t{{\n", itemName, ntype);
		sourcefileBody_ += fmt::format("\t\t\t{} tvalue = ({})value;\n\t\t\treturn new {}(tvalue);\n\t\t}}\n\n", ntype, ntype, itemName);

		sourcefileBody_ += fmt::format("\t\tpublic float x\n\t\t{{\n", ntype, itemName);
		sourcefileBody_ += fmt::format("\t\t\tget {{ return value.x; }}\n\t\t\tset {{ this.value.x = value; }}\n\t\t}}\n\n");

		sourcefileBody_ += fmt::format("\t\tpublic float y\n\t\t{{\n", ntype, itemName);
		sourcefileBody_ += fmt::format("\t\t\tget {{ return value.y; }}\n\t\t\tset {{ this.value.y = value; }}\n\t\t}}\n\n");

		if (ntype == "Vector3")
		{
			sourcefileBody_ += fmt::format("\t\tpublic float z\n\t\t{{\n", ntype, itemName);
			sourcefileBody_ += fmt::format("\t\t\tget {{ return value.z; }}\n\t\t\tset {{ this.value.z = value; }}\n\t\t}}\n\n");
		}

		if (ntype == "Vector4")
		{
			sourcefileBody_ += fmt::format("\t\tpublic float z\n\t\t{{\n", ntype, itemName);
			sourcefileBody_ += fmt::format("\t\t\tget {{ return value.z; }}\n\t\t\tset {{ this.value.z = value; }}\n\t\t}}\n\n");

			sourcefileBody_ += fmt::format("\t\tpublic float w\n\t\t{{\n", ntype, itemName);
			sourcefileBody_ += fmt::format("\t\t\tget {{ return value.w; }}\n\t\t\tset {{ this.value.w = value; }}\n\t\t}}\n");
		}
	}

	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKGodot::writeTypeItemType_INT8(const std::string& itemName, const std::string& childItemName)
{
	sourcefileBody_ += fmt::format("\t\tpublic SByte {} = 0;\n", itemName);
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKGodot::writeTypeItemType_INT16(const std::string& itemName, const std::string& childItemName)
{
	sourcefileBody_ += fmt::format("\t\tpublic Int16 {} = 0;\n", itemName);
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKGodot::writeTypeItemType_INT32(const std::string& itemName, const std::string& childItemName)
{
	sourcefileBody_ += fmt::format("\t\tpublic Int32 {} = 0;\n", itemName);
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKGodot::writeTypeItemType_INT64(const std::string& itemName, const std::string& childItemName)
{
	sourcefileBody_ += fmt::format("\t\tpublic Int64 {} = 0;\n", itemName);
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKGodot::writeTypeItemType_UINT8(const std::string& itemName, const std::string& childItemName)
{
	sourcefileBody_ += fmt::format("\t\tpublic Byte {} = 0;\n", itemName);
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKGodot::writeTypeItemType_UINT16(const std::string& itemName, const std::string& childItemName)
{
	sourcefileBody_ += fmt::format("\t\tpublic UInt16 {} = 0;\n", itemName);
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKGodot::writeTypeItemType_UINT32(const std::string& itemName, const std::string& childItemName)
{
	sourcefileBody_ += fmt::format("\t\tpublic UInt32 {} = 0;\n", itemName);
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKGodot::writeTypeItemType_UINT64(const std::string& itemName, const std::string& childItemName)
{
	sourcefileBody_ += fmt::format("\t\tpublic UInt64 {} = 0;\n", itemName);
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKGodot::writeTypeItemType_FLOAT(const std::string& itemName, const std::string& childItemName)
{
	sourcefileBody_ += fmt::format("\t\tpublic float {} = 0f;\n", itemName);
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKGodot::writeTypeItemType_DOUBLE(const std::string& itemName, const std::string& childItemName)
{
	sourcefileBody_ += fmt::format("\t\tpublic double {} = 0d;\n", itemName);
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKGodot::writeTypeItemType_STRING(const std::string& itemName, const std::string& childItemName)
{
	sourcefileBody_ += fmt::format("\t\tpublic string {} = \"\";\n", itemName);
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKGodot::writeTypeItemType_UNICODE(const std::string& itemName, const std::string& childItemName)
{
	sourcefileBody_ += fmt::format("\t\tpublic string {} = \"\";\n", itemName);
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKGodot::writeTypeItemType_PYTHON(const std::string& itemName, const std::string& childItemName)
{
	return writeTypeItemType_BLOB(itemName, childItemName);
}

//-------------------------------------------------------------------------------------
bool ClientSDKGodot::writeTypeItemType_PY_DICT(const std::string& itemName, const std::string& childItemName)
{
	return writeTypeItemType_BLOB(itemName, childItemName);
}

//-------------------------------------------------------------------------------------
bool ClientSDKGodot::writeTypeItemType_PY_TUPLE(const std::string& itemName, const std::string& childItemName)
{
	return writeTypeItemType_BLOB(itemName, childItemName);
}

//-------------------------------------------------------------------------------------
bool ClientSDKGodot::writeTypeItemType_PY_LIST(const std::string& itemName, const std::string& childItemName)
{
	return writeTypeItemType_BLOB(itemName, childItemName);
}

//-------------------------------------------------------------------------------------
bool ClientSDKGodot::writeTypeItemType_BLOB(const std::string& itemName, const std::string& childItemName)
{
	sourcefileBody_ += fmt::format("\t\tpublic byte[] {} = new byte[0];\n", itemName);
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKGodot::writeTypeItemType_ARRAY(const std::string& itemName, const std::string& childItemName, DataType* pDataType)
{
	std::string typeStr;

	if (childItemName.size() == 0 || childItemName[0] == '_')
	{
		getArrayType(pDataType, typeStr);
	}
	else
	{
		typeStr = childItemName;
	}

	sourcefileBody_ += fmt::format("\t\tpublic {} {} = new {}();\n", typeStr, itemName, typeStr);
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKGodot::writeTypeItemType_FIXED_DICT(const std::string& itemName, const std::string& childItemName, DataType* pDataType)
{
	sourcefileBody_ += fmt::format("\t\tpublic {} {} = new {}();\n", childItemName, itemName, childItemName);
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKGodot::writeTypeItemType_VECTOR2(const std::string& itemName, const std::string& childItemName)
{
#ifdef CLIENT_NO_FLOAT
	sourcefileBody_ += fmt::format("\t\tpublic Vector2Int {} = new Vector2Int(0, 0);\n", itemName);
#else
	sourcefileBody_ += fmt::format("\t\tpublic Vector2 {} = new Vector2(0f, 0f);\n", itemName);
#endif

	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKGodot::writeTypeItemType_VECTOR3(const std::string& itemName, const std::string& childItemName)
{
#ifdef CLIENT_NO_FLOAT
	sourcefileBody_ += fmt::format("\t\tpublic Vector3Int {} = new Vector3Int(0, 0, 0);\n", itemName);
#else
	sourcefileBody_ += fmt::format("\t\tpublic Vector3 {} = new Vector3(0f, 0f, 0f);\n", itemName);
#endif

	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKGodot::writeTypeItemType_VECTOR4(const std::string& itemName, const std::string& childItemName)
{
#ifdef CLIENT_NO_FLOAT
	sourcefileBody_ += fmt::format("\t\tpublic Vector4Int {} = new Vector4Int(0, 0, 0, 0);\n", itemName);
#else
	sourcefileBody_ += fmt::format("\t\tpublic Vector4 {} = new Vector4(0f, 0f, 0f, 0f);\n", itemName);
#endif

	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKGodot::writeTypeItemType_ENTITYCALL(const std::string& itemName, const std::string& childItemName)
{
	sourcefileBody_ += fmt::format("\t\tpublic byte[] {} = new byte[0];\n", itemName);
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKGodot::writeEntityModuleBegin(ScriptDefModule* pEntityScriptDefModule)
{
	std::string newModuleName = fmt::format("{}{}", pEntityScriptDefModule->getName(), moduleSuffix);

	sourcefileBody_ = headerBody;
	strutil::kbe_replace(sourcefileBody_, "#REPLACE#", fmt::format("\tPlease inherit this module, such as: (class {} : {}{})\n",
		pEntityScriptDefModule->getName(), pEntityScriptDefModule->getName(), moduleSuffix));

	sourcefileBody_ += "namespace KBEngine\n{\n";
	sourcefileBody_ += "\tusing UnityEngine;\n";
	sourcefileBody_ += "\tusing System;\n";
	sourcefileBody_ += "\tusing System.Collections;\n";
	sourcefileBody_ += "\tusing System.Collections.Generic;\n\n";

	sourcefileBody_ += std::string("\t// defined in */scripts/entity_defs/") + pEntityScriptDefModule->getName() + ".def\n";

	if (pEntityScriptDefModule->isComponentModule())
	{
		sourcefileBody_ += fmt::format("\tpublic abstract class {} : EntityComponent\n\t{{\n", newModuleName);
	}
	else
	{
		sourcefileBody_ += fmt::format("\t// Please inherit and implement \"class {} : {}\"\n", pEntityScriptDefModule->getName(), newModuleName);
		sourcefileBody_ += fmt::format("\tpublic abstract class {} : Entity\n\t{{\n", newModuleName);

		// 写entityCall属性
		sourcefileBody_ += fmt::format("\t\tpublic EntityBaseEntityCall_{} baseEntityCall = null;\n", newModuleName);
		sourcefileBody_ += fmt::format("\t\tpublic EntityCellEntityCall_{} cellEntityCall = null;\n\n", newModuleName);
	}

	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKGodot::writeEntityModuleEnd(ScriptDefModule* pEntityScriptDefModule)
{
	sourcefileBody_ += "\t}\n}";
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKGodot::getArrayType(DataType* pDataType, std::string& outstr)
{
	if (pDataType->type() == DATA_TYPE_FIXEDARRAY)
	{
		FixedArrayType* pFixedArrayType = static_cast<FixedArrayType*>(pDataType);

		// 如果元素又是数组
		if (pFixedArrayType->getDataType()->type() == DATA_TYPE_FIXEDARRAY)
		{
			if (outstr.size() > 0)
				strutil::kbe_replace(outstr, pDataType->aliasName(), fmt::format("List<{}>", pFixedArrayType->getDataType()->aliasName()));
			else
				outstr = fmt::format("List<{}>", pFixedArrayType->getDataType()->aliasName());

			return getArrayType(pFixedArrayType->getDataType(), outstr);
		}
		else if (pFixedArrayType->getDataType()->type() == DATA_TYPE_FIXEDDICT)
		{
			if (outstr.size() > 0)
				strutil::kbe_replace(outstr, pDataType->aliasName(), pFixedArrayType->getDataType()->aliasName());
			else
				outstr = pFixedArrayType->getDataType()->aliasName();
		}
		else
		{
			if (outstr.size() > 0)
				strutil::kbe_replace(outstr, pDataType->aliasName(), "var");
			else
				outstr = "var";
		}
	}

	outstr = fmt::format("List<{}>", outstr);
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKGodot::writeEntityProcessMessagesMethod(ScriptDefModule* pEntityScriptDefModule)
{
	std::string ownstr = "";
	if (pEntityScriptDefModule->isComponentModule())
		ownstr = "owner.";

	// entityCall
	std::string newModuleName = fmt::format("{}{}", pEntityScriptDefModule->getName(), moduleSuffix);

	if (!pEntityScriptDefModule->isComponentModule())
	{
		sourcefileBody_ += fmt::format("\n\t\tpublic {}()\n\t\t{{\n", newModuleName);
		ScriptDefModule::PROPERTYDESCRIPTION_MAP clientPropertys = pEntityScriptDefModule->getClientPropertyDescriptions();
		ScriptDefModule::PROPERTYDESCRIPTION_MAP::const_iterator propIter = clientPropertys.begin();
		for (; propIter != clientPropertys.end(); ++propIter)
		{
			PropertyDescription* pPropertyDescription = propIter->second;

			if (pPropertyDescription->getDataType()->type() != DATA_TYPE_ENTITY_COMPONENT)
				continue;

			EntityComponentType * pEntityComponentType = (EntityComponentType*)pPropertyDescription->getDataType();

			sourcefileBody_ += fmt::format("\t\t\tforeach (System.Reflection.Assembly ass in AppDomain.CurrentDomain.GetAssemblies())\n\t\t\t{{\n");
			sourcefileBody_ += fmt::format("\t\t\t\tType entityComponentScript = ass.GetType(\"KBEngine.{}\");\n", pEntityComponentType->pScriptDefModule()->getName());
			sourcefileBody_ += fmt::format("\t\t\t\tif(entityComponentScript != null)\n\t\t\t\t{{\n");
			sourcefileBody_ += fmt::format("\t\t\t\t\t{} = ({}{})Activator.CreateInstance(entityComponentScript);\n", pPropertyDescription->getName(), pEntityComponentType->pScriptDefModule()->getName(), moduleSuffix);
			sourcefileBody_ += fmt::format("\t\t\t\t\t{}.owner = this;\n", pPropertyDescription->getName());
			sourcefileBody_ += fmt::format("\t\t\t\t}}\n\t\t\t}}\n\n");

			sourcefileBody_ += fmt::format("\t\t\tif({} == null)\n", pPropertyDescription->getName());
			sourcefileBody_ += fmt::format("\t\t\t\tthrow new Exception(\"Please inherit and implement, such as: \\\"class {} : {}{}\\\"\");\n\n", pEntityComponentType->pScriptDefModule()->getName(), pEntityComponentType->pScriptDefModule()->getName(), moduleSuffix);
		}

		sourcefileBody_ += "\t\t}\n";

		sourcefileBody_ += fmt::format("\n\t\tpublic override void onGetBase()\n\t\t{{\n");
		sourcefileBody_ += fmt::format("\t\t\tbaseEntityCall = new EntityBaseEntityCall_{}(id, className);\n", newModuleName);
		sourcefileBody_ += "\t\t}\n";

		sourcefileBody_ += fmt::format("\n\t\tpublic override void onGetCell()\n\t\t{{\n");
		sourcefileBody_ += fmt::format("\t\t\tcellEntityCall = new EntityCellEntityCall_{}(id, className);\n", newModuleName);
		sourcefileBody_ += "\t\t}\n";

		sourcefileBody_ += fmt::format("\n\t\tpublic override void onLoseCell()\n\t\t{{\n");
		sourcefileBody_ += fmt::format("\t\t\tcellEntityCall = null;\n");
		sourcefileBody_ += "\t\t}\n";

		sourcefileBody_ += fmt::format("\n\t\tpublic override EntityCall getBaseEntityCall()\n\t\t{{\n");
		sourcefileBody_ += fmt::format("\t\t\treturn baseEntityCall;\n");
		sourcefileBody_ += "\t\t}\n";

		sourcefileBody_ += fmt::format("\n\t\tpublic override EntityCall getCellEntityCall()\n\t\t{{\n");
		sourcefileBody_ += fmt::format("\t\t\treturn cellEntityCall;\n");
		sourcefileBody_ += "\t\t}\n";
	}

	// 处理方法
	if (!pEntityScriptDefModule->isComponentModule())
		sourcefileBody_ += fmt::format("\n\t\tpublic override void onRemoteMethodCall(MemoryStream stream)\n\t\t{{\n");
	else
		sourcefileBody_ += fmt::format("\n\t\tpublic override void onRemoteMethodCall(UInt16 methodUtype, MemoryStream stream)\n\t\t{{\n");

	sourcefileBody_ += fmt::format("\t\t\tScriptModule sm = EntityDef.moduledefs[\"{}\"];\n\n", pEntityScriptDefModule->getName());
	
	if (!pEntityScriptDefModule->isComponentModule())
	{
		sourcefileBody_ += fmt::format("\t\t\tUInt16 methodUtype = 0;\n");
		sourcefileBody_ += fmt::format("\t\t\tUInt16 componentPropertyUType = 0;\n\n");

		sourcefileBody_ += fmt::format("\t\t\tif(sm.useMethodDescrAlias)\n");
		sourcefileBody_ += fmt::format("\t\t\t{{\n");
		sourcefileBody_ += fmt::format("\t\t\t\tcomponentPropertyUType = stream.readUint8();\n");
		sourcefileBody_ += fmt::format("\t\t\t\tmethodUtype = stream.readUint8();\n");
		sourcefileBody_ += fmt::format("\t\t\t}}\n");
		sourcefileBody_ += fmt::format("\t\t\telse\n");
		sourcefileBody_ += fmt::format("\t\t\t{{\n");
		sourcefileBody_ += fmt::format("\t\t\t\tcomponentPropertyUType = stream.readUint16();\n");
		sourcefileBody_ += fmt::format("\t\t\t\tmethodUtype = stream.readUint16();\n");
		sourcefileBody_ += fmt::format("\t\t\t}}\n\n");

		sourcefileBody_ += fmt::format("\t\t\tMethod method = null;\n\n");

		sourcefileBody_ += fmt::format("\t\t\tif(componentPropertyUType == 0)\n");
		sourcefileBody_ += fmt::format("\t\t\t{{\n");
		sourcefileBody_ += fmt::format("\t\t\t\tmethod = sm.idmethods[methodUtype];\n");
		sourcefileBody_ += fmt::format("\t\t\t}}\n");
		sourcefileBody_ += fmt::format("\t\t\telse\n");
		sourcefileBody_ += fmt::format("\t\t\t{{\n");
		sourcefileBody_ += fmt::format("\t\t\t\tProperty pComponentPropertyDescription = sm.idpropertys[componentPropertyUType];\n");

		sourcefileBody_ += fmt::format("\t\t\t\tswitch(pComponentPropertyDescription.properUtype)\n\t\t\t\t{{\n");

		ScriptDefModule::PROPERTYDESCRIPTION_MAP clientPropertys = pEntityScriptDefModule->getClientPropertyDescriptions();
		ScriptDefModule::PROPERTYDESCRIPTION_MAP::const_iterator propIter = clientPropertys.begin();
		for (; propIter != clientPropertys.end(); ++propIter)
		{
			PropertyDescription* pPropertyDescription = propIter->second;

			if (pPropertyDescription->getDataType()->type() != DATA_TYPE_ENTITY_COMPONENT)
				continue;

			
			sourcefileBody_ += fmt::format("\t\t\t\t\tcase {}:\n", pPropertyDescription->getUType());
			sourcefileBody_ += fmt::format("\t\t\t\t\t\t{}.onRemoteMethodCall(methodUtype, stream);\n", pPropertyDescription->getName());
			sourcefileBody_ += fmt::format("\t\t\t\t\t\tbreak;\n");
		}

		sourcefileBody_ += fmt::format("\t\t\t\t\tdefault:\n");
		sourcefileBody_ += fmt::format("\t\t\t\t\t\tbreak;\n");
		sourcefileBody_ += fmt::format("\t\t\t\t}}\n\n");
		sourcefileBody_ += fmt::format("\t\t\t\treturn;\n");
		sourcefileBody_ += fmt::format("\t\t\t}}\n\n");

		sourcefileBody_ += fmt::format("\t\t\tswitch(method.methodUtype)\n\t\t\t{{\n");
	}
	else
	{
		sourcefileBody_ += fmt::format("\t\t\tMethod method = sm.idmethods[methodUtype];\n");
		sourcefileBody_ += fmt::format("\t\t\tswitch(method.methodUtype)\n\t\t\t{{\n");
	}

	ScriptDefModule::METHODDESCRIPTION_MAP& clientMethods = pEntityScriptDefModule->getClientMethodDescriptions();
	ScriptDefModule::METHODDESCRIPTION_MAP::iterator methodIter = clientMethods.begin();
	for (; methodIter != clientMethods.end(); ++methodIter)
	{
		MethodDescription* pMethodDescription = methodIter->second;

		sourcefileBody_ += fmt::format("\t\t\t\tcase {}:\n", pMethodDescription->getUType());
		
		std::vector<DataType*>& argTypes = pMethodDescription->getArgTypes();
		std::vector<DataType*>::iterator iter = argTypes.begin();

		int i = 1;
		std::string argsStr;

		for (; iter != argTypes.end(); ++iter)
		{
			DataType* pDataType = (*iter);

			uint16 typeID = datatype2id(pDataType->getName());
			if (typeID == 0 || strcmp(pDataType->getName(), "FIXED_DICT") == 0 || strcmp(pDataType->getName(), "ARRAY") == 0)
				typeID = pDataType->id();

			argsStr += fmt::format("{}_arg{}, ", pMethodDescription->getName(), i);

			std::string readName = datatype2nativetype(pDataType->getName());
			if (readName.size() > 0)
			{
				std::transform(readName.begin(), readName.end(), readName.begin(), tolower);
				readName[0] = std::toupper(readName[0]);
			}

			std::string nativetype = datatype2nativetype(typeID);
			if (strcmp(pDataType->getName(), "FIXED_DICT") == 0)
			{
				sourcefileBody_ += fmt::format("\t\t\t\t\t{} {}_arg{} = ((DATATYPE_{})method.args[{}]).createFromStreamEx(stream);\n",
					pDataType->aliasName(), pMethodDescription->getName(), i, pDataType->aliasName(), (i - 1));
			}
			else if(strcmp(pDataType->getName(), "ARRAY") == 0)
			{
				std::string typestr;
				getArrayType(pDataType, typestr);

				if (strlen(pDataType->aliasName()) > 0)
				{
					sourcefileBody_ += fmt::format("\t\t\t\t\t{} {}_arg{} = ((DATATYPE_{})method.args[{}]).createFromStreamEx(stream);\n",
						pDataType->aliasName(), pMethodDescription->getName(), i, pDataType->aliasName(), (i - 1));
				}
				else
				{
					sourcefileBody_ += fmt::format("\t\t\t\t\t{} {}_arg{} = ((DATATYPE_AnonymousArray_{})method.args[{}]).createFromStreamEx(stream);\n",
						typestr, pMethodDescription->getName(), i, typeID, (i - 1));
				}
			}
			else
			{
				sourcefileBody_ += fmt::format("\t\t\t\t\tvar {}_arg{} = stream.read{}();\n",
					pMethodDescription->getName(), i, readName);
			}

			++i;
		}

		if (argsStr.size() > 0)
			argsStr.erase(argsStr.size() - 2, 2);

		sourcefileBody_ += fmt::format("\t\t\t\t\t{}({});\n", pMethodDescription->getName(), argsStr);
		sourcefileBody_ += fmt::format("\t\t\t\t\tbreak;\n");
	}

	sourcefileBody_ += fmt::format("\t\t\t\tdefault:\n");
	sourcefileBody_ += fmt::format("\t\t\t\t\tbreak;\n");
	sourcefileBody_ += fmt::format("\t\t\t}};\n");
	sourcefileBody_ += "\t\t}\n";

	// 处理属性
	ENTITY_PROPERTY_UID posuid = 0;
	if (posuid == 0)
	{
		posuid = ENTITY_BASE_PROPERTY_UTYPE_POSITION_XYZ;
		Network::FixedMessages::MSGInfo* msgInfo =
			Network::FixedMessages::getSingleton().isFixed("Property::position");

		if (msgInfo != NULL)
			posuid = msgInfo->msgid;
	}

	PropertyDescription positionDescription(posuid, "VECTOR3", "position", ED_FLAG_ALL_CLIENTS, true, DataTypes::getDataType("VECTOR3"), false, "", 0, "", DETAIL_LEVEL_FAR);
	if (pEntityScriptDefModule->usePropertyDescrAlias() && positionDescription.aliasID() == -1)
		positionDescription.aliasID(ENTITY_BASE_PROPERTY_ALIASID_POSITION_XYZ);

	ENTITY_PROPERTY_UID diruid = 0;
	if (diruid == 0)
	{
		diruid = ENTITY_BASE_PROPERTY_UTYPE_DIRECTION_ROLL_PITCH_YAW;
		Network::FixedMessages::MSGInfo* msgInfo = Network::FixedMessages::getSingleton().isFixed("Property::direction");
		if (msgInfo != NULL)
			diruid = msgInfo->msgid;
	}

	PropertyDescription directionDescription(diruid, "VECTOR3", "direction", ED_FLAG_ALL_CLIENTS, true, DataTypes::getDataType("VECTOR3"), false, "", 0, "", DETAIL_LEVEL_FAR);
	if (pEntityScriptDefModule->usePropertyDescrAlias() && directionDescription.aliasID() == -1)
		directionDescription.aliasID(ENTITY_BASE_PROPERTY_ALIASID_DIRECTION_ROLL_PITCH_YAW);

	ENTITY_PROPERTY_UID spaceuid = 0;
	if (spaceuid == 0)
	{
		spaceuid = ENTITY_BASE_PROPERTY_UTYPE_SPACEID;
		Network::FixedMessages::MSGInfo* msgInfo = Network::FixedMessages::getSingleton().isFixed("Property::spaceID");
		if (msgInfo != NULL)
			spaceuid = msgInfo->msgid;
	}

	PropertyDescription spaceDescription(spaceuid, "UINT32", "spaceID", ED_FLAG_OWN_CLIENT, true, DataTypes::getDataType("UINT32"), false, "", 0, "", DETAIL_LEVEL_FAR);
	if (pEntityScriptDefModule->usePropertyDescrAlias() && spaceDescription.aliasID() == -1)
		spaceDescription.aliasID(ENTITY_BASE_PROPERTY_ALIASID_SPACEID);

	if(pEntityScriptDefModule->isComponentModule())
		sourcefileBody_ += fmt::format("\n\t\tpublic override void onUpdatePropertys(UInt16 propUtype, MemoryStream stream, int maxCount)\n\t\t{{\n");
	else
		sourcefileBody_ += fmt::format("\n\t\tpublic override void onUpdatePropertys(MemoryStream stream)\n\t\t{{\n");

	sourcefileBody_ += fmt::format("\t\t\tScriptModule sm = EntityDef.moduledefs[\"{}\"];\n", pEntityScriptDefModule->getName());
	sourcefileBody_ += fmt::format("\t\t\tDictionary<UInt16, Property> pdatas = sm.idpropertys;\n\n");

	if (pEntityScriptDefModule->isComponentModule())
		sourcefileBody_ += fmt::format("\t\t\twhile(stream.length() > 0 && maxCount-- != 0)\n");
	else
		sourcefileBody_ += fmt::format("\t\t\twhile(stream.length() > 0)\n");

	sourcefileBody_ += fmt::format("\t\t\t{{\n");

	sourcefileBody_ += fmt::format("\t\t\t\tUInt16 _t_utype = 0;\n");

	if (pEntityScriptDefModule->isComponentModule())
	{
		sourcefileBody_ += fmt::format("\t\t\t\tUInt16 _t_child_utype = propUtype;\n\n");
		sourcefileBody_ += fmt::format("\t\t\t\tif(_t_child_utype == 0)\n");
	}
	else
	{
		sourcefileBody_ += fmt::format("\t\t\t\tUInt16 _t_child_utype = 0;\n\n");
	}

	sourcefileBody_ += fmt::format("\t\t\t\t{{\n");
	sourcefileBody_ += fmt::format("\t\t\t\t\tif(sm.usePropertyDescrAlias)\n");
	sourcefileBody_ += fmt::format("\t\t\t\t\t{{\n");
	sourcefileBody_ += fmt::format("\t\t\t\t\t\t_t_utype = stream.readUint8();\n");
	sourcefileBody_ += fmt::format("\t\t\t\t\t\t_t_child_utype = stream.readUint8();\n");
	sourcefileBody_ += fmt::format("\t\t\t\t\t}}\n");
	sourcefileBody_ += fmt::format("\t\t\t\t\telse\n");
	sourcefileBody_ += fmt::format("\t\t\t\t\t{{\n");
	sourcefileBody_ += fmt::format("\t\t\t\t\t\t_t_utype = stream.readUint16();\n");
	sourcefileBody_ += fmt::format("\t\t\t\t\t\t_t_child_utype = stream.readUint16();\n");
	sourcefileBody_ += fmt::format("\t\t\t\t\t}}\n");
	sourcefileBody_ += fmt::format("\t\t\t\t}}\n\n");

	sourcefileBody_ += fmt::format("\t\t\t\tProperty prop = null;\n\n");

	if (pEntityScriptDefModule->isComponentModule())
	{
		sourcefileBody_ += fmt::format("\t\t\t\tprop = pdatas[_t_child_utype];\n\n");
	}
	else
	{
		sourcefileBody_ += fmt::format("\t\t\t\tif(_t_utype == 0)\n");
		sourcefileBody_ += fmt::format("\t\t\t\t{{\n");
		sourcefileBody_ += fmt::format("\t\t\t\t\tprop = pdatas[_t_child_utype];\n");
		sourcefileBody_ += fmt::format("\t\t\t\t}}\n");
		sourcefileBody_ += fmt::format("\t\t\t\telse\n");
		sourcefileBody_ += fmt::format("\t\t\t\t{{\n");

		sourcefileBody_ += fmt::format("\t\t\t\t\tProperty pComponentPropertyDescription = pdatas[_t_utype];\n");

		sourcefileBody_ += fmt::format("\t\t\t\t\tswitch(pComponentPropertyDescription.properUtype)\n\t\t\t\t\t{{\n");

		ScriptDefModule::PROPERTYDESCRIPTION_MAP clientPropertys = pEntityScriptDefModule->getClientPropertyDescriptions();
		ScriptDefModule::PROPERTYDESCRIPTION_MAP::const_iterator propIter = clientPropertys.begin();
		for (; propIter != clientPropertys.end(); ++propIter)
		{
			PropertyDescription* pPropertyDescription = propIter->second;

			if (pPropertyDescription->getDataType()->type() != DATA_TYPE_ENTITY_COMPONENT)
				continue;


			sourcefileBody_ += fmt::format("\t\t\t\t\t\tcase {}:\n", pPropertyDescription->getUType());
			sourcefileBody_ += fmt::format("\t\t\t\t\t\t\t{}.onUpdatePropertys(_t_child_utype, stream, -1);\n", pPropertyDescription->getName());
			sourcefileBody_ += fmt::format("\t\t\t\t\t\t\tbreak;\n");
		}

		sourcefileBody_ += fmt::format("\t\t\t\t\t\tdefault:\n");
		sourcefileBody_ += fmt::format("\t\t\t\t\t\t\tbreak;\n");
		sourcefileBody_ += fmt::format("\t\t\t\t\t}}\n\n");
		sourcefileBody_ += fmt::format("\t\t\t\t\treturn;\n");
		sourcefileBody_ += fmt::format("\t\t\t\t}}\n\n");
	}

	sourcefileBody_ += fmt::format("\t\t\t\tswitch(prop.properUtype)\n\t\t\t\t{{\n");

	ScriptDefModule::PROPERTYDESCRIPTION_MAP clientPropertys = pEntityScriptDefModule->getClientPropertyDescriptions();

	if (!pEntityScriptDefModule->isComponentModule())
	{
		clientPropertys[positionDescription.getName()] = &positionDescription;
		clientPropertys[directionDescription.getName()] = &directionDescription;
		clientPropertys[spaceDescription.getName()] = &spaceDescription;
	}

	ScriptDefModule::PROPERTYDESCRIPTION_MAP::const_iterator propIter = clientPropertys.begin();
	for (; propIter != clientPropertys.end(); ++propIter)
	{
		PropertyDescription* pPropertyDescription = propIter->second;

		if (pPropertyDescription->getDataType()->type() == DATA_TYPE_ENTITY_COMPONENT)
		{
			sourcefileBody_ += fmt::format("\t\t\t\t\tcase {}:\n", pPropertyDescription->getUType());
			sourcefileBody_ += fmt::format("\t\t\t\t\t\t{}.createFromStream(stream);\n", pPropertyDescription->getName());
			sourcefileBody_ += fmt::format("\t\t\t\t\t\tbreak;\n");
			continue;
		}

		std::string typestr;

		if (std::string("position") == pPropertyDescription->getName() ||
			std::string("direction") == pPropertyDescription->getName())
		{
#ifdef CLIENT_NO_FLOAT
			typestr = "Vector3Int";
#else
			typestr = "Vector3";
#endif
		}
		else
		{
			if (std::string("spaceID") == pPropertyDescription->getName())
			{
				sourcefileBody_ += fmt::format("\t\t\t\t\tcase {}:\n", pPropertyDescription->getUType());
				sourcefileBody_ += fmt::format("\t\t\t\t\t\tstream.readUint32();\n");
				sourcefileBody_ += fmt::format("\t\t\t\t\t\tbreak;\n");
				continue;
			}
			else
			{
				std::string findstr = fmt::format(" {} = ", pPropertyDescription->getName());
				std::string::size_type fpos2 = sourcefileBody_.find(findstr);
				std::string::size_type fpos1 = sourcefileBody_.rfind(" ", fpos2 - 1);
				typestr.assign(sourcefileBody_.begin() + fpos1 + 1, sourcefileBody_.begin() + fpos2);
			}
		}

		sourcefileBody_ += fmt::format("\t\t\t\t\tcase {}:\n", pPropertyDescription->getUType());
		sourcefileBody_ += fmt::format("\t\t\t\t\t\t{} oldval_{} = {};\n", typestr, pPropertyDescription->getName(), pPropertyDescription->getName());

		std::string readName = datatype2nativetype(pPropertyDescription->getDataType()->getName());
		if (readName.size() > 0)
		{
			std::transform(readName.begin(), readName.end(), readName.begin(), tolower);
			readName[0] = std::toupper(readName[0]);
		}
		else
		{
			KBE_ASSERT(false);
		}

		if (pPropertyDescription->getDataType()->type() == DATA_TYPE_FIXEDDICT)
		{
			readName = fmt::format("((DATATYPE_{})EntityDef.id2datatypes[{}]).createFromStreamEx(stream)", 
				pPropertyDescription->getDataType()->aliasName(), pPropertyDescription->getDataType()->id());
		}
		else if (pPropertyDescription->getDataType()->type() == DATA_TYPE_FIXEDARRAY)
		{
			if (strlen(pPropertyDescription->getDataType()->aliasName()) > 0)
			{
				readName = fmt::format("((DATATYPE_{})EntityDef.id2datatypes[{}]).createFromStreamEx(stream)", 
					pPropertyDescription->getDataType()->aliasName(), pPropertyDescription->getDataType()->id());
			}
			else
			{
				readName = fmt::format("((DATATYPE_AnonymousArray_{})EntityDef.id2datatypes[{}]).createFromStreamEx(stream)", 
					pPropertyDescription->getDataType()->id(), pPropertyDescription->getDataType()->id());
			}
		}
		else
		{
			readName = fmt::format("stream.read{}()", readName);
		}

		sourcefileBody_ += fmt::format("\t\t\t\t\t\t{} = {};\n", pPropertyDescription->getName(), readName);

		std::string name = pPropertyDescription->getName();
		name[0] = std::toupper(name[0]);
		sourcefileBody_ += fmt::format("\n\t\t\t\t\t\tif(prop.isBase())\n\t\t\t\t\t\t{{\n");
		sourcefileBody_ += fmt::format("\t\t\t\t\t\t\tif({}inited)\n", ownstr);
		sourcefileBody_ += fmt::format("\t\t\t\t\t\t\t\ton{}Changed(oldval_{});\n\t\t\t\t\t\t}}\n", name, pPropertyDescription->getName());
		sourcefileBody_ += fmt::format("\t\t\t\t\t\telse\n\t\t\t\t\t\t{{\n");
		sourcefileBody_ += fmt::format("\t\t\t\t\t\t\tif({}inWorld)\n", ownstr);
		sourcefileBody_ += fmt::format("\t\t\t\t\t\t\t\ton{}Changed(oldval_{});\n", name, pPropertyDescription->getName());
		sourcefileBody_ += fmt::format("\t\t\t\t\t\t}}\n\n");
		sourcefileBody_ += fmt::format("\t\t\t\t\t\tbreak;\n");
	}

	sourcefileBody_ += fmt::format("\t\t\t\t\tdefault:\n");
	sourcefileBody_ += fmt::format("\t\t\t\t\t\tbreak;\n");
	sourcefileBody_ += fmt::format("\t\t\t\t}};\n");

	sourcefileBody_ += fmt::format("\t\t\t}}\n");
	sourcefileBody_ += "\t\t}\n";

	// 处理属性callPropertysSetMethods
	sourcefileBody_ += fmt::format("\n\t\tpublic override void callPropertysSetMethods()\n\t\t{{\n");
	sourcefileBody_ += fmt::format("\t\t\tScriptModule sm = EntityDef.moduledefs[\"{}\"];\n", pEntityScriptDefModule->getName());
	sourcefileBody_ += fmt::format("\t\t\tDictionary<UInt16, Property> pdatas = sm.idpropertys;\n\n");

	propIter = clientPropertys.begin();
	for (; propIter != clientPropertys.end(); ++propIter)
	{
		PropertyDescription* pPropertyDescription = propIter->second;

		std::string typestr;

		if (std::string("spaceID") == pPropertyDescription->getName())
			continue;

		if (std::string("position") == pPropertyDescription->getName() ||
			std::string("direction") == pPropertyDescription->getName())
		{
#ifdef CLIENT_NO_FLOAT
			typestr = "Vector3Int";
#else
			typestr = "Vector3";
#endif
		}
		else
		{
			std::string findstr = fmt::format(" {} = ", pPropertyDescription->getName());
			std::string::size_type fpos2 = sourcefileBody_.find(findstr);
			std::string::size_type fpos1 = sourcefileBody_.rfind(" ", fpos2 - 1);
			typestr.assign(sourcefileBody_.begin() + fpos1 + 1, sourcefileBody_.begin() + fpos2);
		}

		if (pPropertyDescription->getDataType()->type() == DATA_TYPE_ENTITY_COMPONENT)
		{
			sourcefileBody_ += fmt::format("\t\t\t{}.callPropertysSetMethods();\n\n", pPropertyDescription->getName());
		}
		else
		{
			sourcefileBody_ += fmt::format("\t\t\t{} oldval_{} = {};\n", typestr, pPropertyDescription->getName(), pPropertyDescription->getName());

			std::string name = pPropertyDescription->getName();
			name[0] = std::toupper(name[0]);

			sourcefileBody_ += fmt::format("\t\t\tProperty prop_{} = pdatas[{}];\n", pPropertyDescription->getName(), (pEntityScriptDefModule->usePropertyDescrAlias() ?
				pPropertyDescription->aliasID() : pPropertyDescription->getUType()));

			sourcefileBody_ += fmt::format("\t\t\tif(prop_{}.isBase())\n\t\t\t{{\n", pPropertyDescription->getName());
			sourcefileBody_ += fmt::format("\t\t\t\tif({}inited && !{}inWorld)\n", ownstr, ownstr);
			sourcefileBody_ += fmt::format("\t\t\t\t\ton{}Changed(oldval_{});\n", name, pPropertyDescription->getName());
			sourcefileBody_ += fmt::format("\t\t\t}}\n\t\t\telse\n\t\t\t{{\n");
			sourcefileBody_ += fmt::format("\t\t\t\tif({}inWorld)\n\t\t\t\t{{\n", ownstr);
			sourcefileBody_ += fmt::format("\t\t\t\t\tif(prop_{}.isOwnerOnly() && !{}isPlayer())\n\t\t\t\t\t{{\n\t\t\t\t\t}}\n\t\t\t\t\telse\n\t\t\t\t\t{{\n", pPropertyDescription->getName(), ownstr);
			sourcefileBody_ += fmt::format("\t\t\t\t\t\ton{}Changed(oldval_{});\n\t\t\t\t\t}}\n", name, pPropertyDescription->getName());
			sourcefileBody_ += fmt::format("\t\t\t\t}}\n\t\t\t}}\n\n");
		}
	}

	sourcefileBody_ += "\t\t}\n";

	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKGodot::writeEntityPropertyComponent(ScriptDefModule* pEntityScriptDefModule,
	ScriptDefModule* pCurrScriptDefModule, PropertyDescription* pPropertyDescription)
{
	EntityComponentType * pEntityComponentType = (EntityComponentType*)pPropertyDescription->getDataType();
	
	sourcefileBody_ += fmt::format("\t\tpublic {}{} {} = null;\n", pEntityComponentType->pScriptDefModule()->getName(), moduleSuffix, pPropertyDescription->getName(),
		pEntityComponentType->pScriptDefModule()->getName());

	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKGodot::writeEntityProperty_INT8(ScriptDefModule* pEntityScriptDefModule,
	ScriptDefModule* pCurrScriptDefModule, PropertyDescription* pPropertyDescription)
{
	sourcefileBody_ += fmt::format("\t\tpublic SByte {} = {};\n", pPropertyDescription->getName(),
		(strlen(pPropertyDescription->getDefaultValStr()) > 0 ? pPropertyDescription->getDefaultValStr() : "0"));

	std::string name = pPropertyDescription->getName();
	name[0] = std::toupper(name[0]);
	sourcefileBody_ += fmt::format("\t\tpublic virtual void on{}Changed(SByte oldValue) {{}}\n", name);
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKGodot::writeEntityProperty_INT16(ScriptDefModule* pEntityScriptDefModule,
	ScriptDefModule* pCurrScriptDefModule, PropertyDescription* pPropertyDescription)
{
	sourcefileBody_ += fmt::format("\t\tpublic Int16 {} = {};\n", pPropertyDescription->getName(),
		(strlen(pPropertyDescription->getDefaultValStr()) > 0 ? pPropertyDescription->getDefaultValStr() : "0"));

	std::string name = pPropertyDescription->getName();
	name[0] = std::toupper(name[0]);
	sourcefileBody_ += fmt::format("\t\tpublic virtual void on{}Changed(Int16 oldValue) {{}}\n", name);
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKGodot::writeEntityProperty_INT32(ScriptDefModule* pEntityScriptDefModule,
	ScriptDefModule* pCurrScriptDefModule, PropertyDescription* pPropertyDescription)
{
	sourcefileBody_ += fmt::format("\t\tpublic Int32 {} = {};\n", pPropertyDescription->getName(),
		(strlen(pPropertyDescription->getDefaultValStr()) > 0 ? pPropertyDescription->getDefaultValStr() : "0"));

	std::string name = pPropertyDescription->getName();
	name[0] = std::toupper(name[0]);
	sourcefileBody_ += fmt::format("\t\tpublic virtual void on{}Changed(Int32 oldValue) {{}}\n", name);
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKGodot::writeEntityProperty_INT64(ScriptDefModule* pEntityScriptDefModule,
	ScriptDefModule* pCurrScriptDefModule, PropertyDescription* pPropertyDescription)
{
	sourcefileBody_ += fmt::format("\t\tpublic Int64 {} = {};\n", pPropertyDescription->getName(),
		(strlen(pPropertyDescription->getDefaultValStr()) > 0 ? pPropertyDescription->getDefaultValStr() : "0"));

	std::string name = pPropertyDescription->getName();
	name[0] = std::toupper(name[0]);
	sourcefileBody_ += fmt::format("\t\tpublic virtual void on{}Changed(Int64 oldValue) {{}}\n", name);
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKGodot::writeEntityProperty_UINT8(ScriptDefModule* pEntityScriptDefModule,
	ScriptDefModule* pCurrScriptDefModule, PropertyDescription* pPropertyDescription)
{
	sourcefileBody_ += fmt::format("\t\tpublic Byte {} = {};\n", pPropertyDescription->getName(),
		(strlen(pPropertyDescription->getDefaultValStr()) > 0 ? pPropertyDescription->getDefaultValStr() : "0"));

	std::string name = pPropertyDescription->getName();
	name[0] = std::toupper(name[0]);
	sourcefileBody_ += fmt::format("\t\tpublic virtual void on{}Changed(Byte oldValue) {{}}\n", name);
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKGodot::writeEntityProperty_UINT16(ScriptDefModule* pEntityScriptDefModule,
	ScriptDefModule* pCurrScriptDefModule, PropertyDescription* pPropertyDescription)
{
	sourcefileBody_ += fmt::format("\t\tpublic UInt16 {} = {};\n", pPropertyDescription->getName(),
		(strlen(pPropertyDescription->getDefaultValStr()) > 0 ? pPropertyDescription->getDefaultValStr() : "0"));

	std::string name = pPropertyDescription->getName();
	name[0] = std::toupper(name[0]);
	sourcefileBody_ += fmt::format("\t\tpublic virtual void on{}Changed(UInt16 oldValue) {{}}\n", name);
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKGodot::writeEntityProperty_UINT32(ScriptDefModule* pEntityScriptDefModule,
	ScriptDefModule* pCurrScriptDefModule, PropertyDescription* pPropertyDescription)
{
	sourcefileBody_ += fmt::format("\t\tpublic UInt32 {} = {};\n", pPropertyDescription->getName(),
		(strlen(pPropertyDescription->getDefaultValStr()) > 0 ? pPropertyDescription->getDefaultValStr() : "0"));

	std::string name = pPropertyDescription->getName();
	name[0] = std::toupper(name[0]);
	sourcefileBody_ += fmt::format("\t\tpublic virtual void on{}Changed(UInt32 oldValue) {{}}\n", name);
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKGodot::writeEntityProperty_UINT64(ScriptDefModule* pEntityScriptDefModule,
	ScriptDefModule* pCurrScriptDefModule, PropertyDescription* pPropertyDescription)
{
	sourcefileBody_ += fmt::format("\t\tpublic UInt64 {} = {};\n", pPropertyDescription->getName(),
		(strlen(pPropertyDescription->getDefaultValStr()) > 0 ? pPropertyDescription->getDefaultValStr() : "0"));

	std::string name = pPropertyDescription->getName();
	name[0] = std::toupper(name[0]);
	sourcefileBody_ += fmt::format("\t\tpublic virtual void on{}Changed(UInt64 oldValue) {{}}\n", name);
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKGodot::writeEntityProperty_FLOAT(ScriptDefModule* pEntityScriptDefModule,
	ScriptDefModule* pCurrScriptDefModule, PropertyDescription* pPropertyDescription)
{
	sourcefileBody_ += fmt::format("\t\tpublic float {} = {}f;\n", pPropertyDescription->getName(),
		(strlen(pPropertyDescription->getDefaultValStr()) > 0 ? pPropertyDescription->getDefaultValStr() : "0f"));

	std::string name = pPropertyDescription->getName();
	name[0] = std::toupper(name[0]);
	sourcefileBody_ += fmt::format("\t\tpublic virtual void on{}Changed(float oldValue) {{}}\n", name);
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKGodot::writeEntityProperty_DOUBLE(ScriptDefModule* pEntityScriptDefModule,
	ScriptDefModule* pCurrScriptDefModule, PropertyDescription* pPropertyDescription)
{
	sourcefileBody_ += fmt::format("\t\tpublic double {} = {};\n", pPropertyDescription->getName(),
		(strlen(pPropertyDescription->getDefaultValStr()) > 0 ? pPropertyDescription->getDefaultValStr() : "0d"));

	std::string name = pPropertyDescription->getName();
	name[0] = std::toupper(name[0]);
	sourcefileBody_ += fmt::format("\t\tpublic virtual void on{}Changed(double oldValue) {{}}\n", name);
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKGodot::writeEntityProperty_STRING(ScriptDefModule* pEntityScriptDefModule,
	ScriptDefModule* pCurrScriptDefModule, PropertyDescription* pPropertyDescription)
{
	sourcefileBody_ += fmt::format("\t\tpublic string {} = {};\n", pPropertyDescription->getName(),
		(strlen(pPropertyDescription->getDefaultValStr()) > 0 ? pPropertyDescription->getDefaultValStr() : "\"\""));

	std::string name = pPropertyDescription->getName();
	name[0] = std::toupper(name[0]);
	sourcefileBody_ += fmt::format("\t\tpublic virtual void on{}Changed(string oldValue) {{}}\n", name);
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKGodot::writeEntityProperty_UNICODE(ScriptDefModule* pEntityScriptDefModule,
	ScriptDefModule* pCurrScriptDefModule, PropertyDescription* pPropertyDescription)
{
	sourcefileBody_ += fmt::format("\t\tpublic string {} = {};\n", pPropertyDescription->getName(),
		(strlen(pPropertyDescription->getDefaultValStr()) > 0 ? pPropertyDescription->getDefaultValStr() : "\"\""));

	std::string name = pPropertyDescription->getName();
	name[0] = std::toupper(name[0]);
	sourcefileBody_ += fmt::format("\t\tpublic virtual void on{}Changed(string oldValue) {{}}\n", name);
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKGodot::writeEntityProperty_PYTHON(ScriptDefModule* pEntityScriptDefModule,
	ScriptDefModule* pCurrScriptDefModule, PropertyDescription* pPropertyDescription)
{
	ERROR_MSG("ClientSDKGodot::writeEntityProperty_PYTHON(): nonsupport!\n");
	return false;
}

//-------------------------------------------------------------------------------------
bool ClientSDKGodot::writeEntityProperty_PY_DICT(ScriptDefModule* pEntityScriptDefModule,
	ScriptDefModule* pCurrScriptDefModule, PropertyDescription* pPropertyDescription)
{
	ERROR_MSG("ClientSDKGodot::writeEntityProperty_PY_DICT(): nonsupport!\n");
	return false;
}

//-------------------------------------------------------------------------------------
bool ClientSDKGodot::writeEntityProperty_PY_TUPLE(ScriptDefModule* pEntityScriptDefModule,
	ScriptDefModule* pCurrScriptDefModule, PropertyDescription* pPropertyDescription)
{
	ERROR_MSG("ClientSDKGodot::writeEntityProperty_PY_TUPLE(): nonsupport!\n");
	return false;
}

//-------------------------------------------------------------------------------------
bool ClientSDKGodot::writeEntityProperty_PY_LIST(ScriptDefModule* pEntityScriptDefModule,
	ScriptDefModule* pCurrScriptDefModule, PropertyDescription* pPropertyDescription)
{
	ERROR_MSG("ClientSDKGodot::writeEntityProperty_PY_LIST(): nonsupport!\n");
	return false;
}

//-------------------------------------------------------------------------------------
bool ClientSDKGodot::writeEntityProperty_BLOB(ScriptDefModule* pEntityScriptDefModule,
	ScriptDefModule* pCurrScriptDefModule, PropertyDescription* pPropertyDescription)
{
	sourcefileBody_ += fmt::format("\t\tpublic byte[] {} = {};\n", pPropertyDescription->getName(),
		(strlen(pPropertyDescription->getDefaultValStr()) > 0 ? pPropertyDescription->getDefaultValStr() : "new byte[0]"));

	std::string name = pPropertyDescription->getName();
	name[0] = std::toupper(name[0]);
	sourcefileBody_ += fmt::format("\t\tpublic virtual void on{}Changed(byte[] oldValue) {{}}\n", name);
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKGodot::writeEntityProperty_ARRAY(ScriptDefModule* pEntityScriptDefModule,
	ScriptDefModule* pCurrScriptDefModule, PropertyDescription* pPropertyDescription)
{
	if (std::string("ARRAY") == pPropertyDescription->getDataTypeName())
	{
		std::string s = sourcefileBody_;
		sourcefileBody_ = "";

		bool ret = writeTypeItemType_ARRAY(pPropertyDescription->getName(), pPropertyDescription->getDataType()->aliasName(), pPropertyDescription->getDataType());
		std::vector<std::string> values;
		values = KBEngine::strutil::kbe_splits(sourcefileBody_, " ");
		sourcefileBody_ = s + sourcefileBody_;

		std::string name = pPropertyDescription->getName();
		name[0] = std::toupper(name[0]);
		sourcefileBody_ += fmt::format("\t\tpublic virtual void on{}Changed({} oldValue) {{}}\n", name, values[1]);
		return ret;
	}
	else
	{
		sourcefileBody_ += fmt::format("\t\tpublic {} {} = new {}();\n", pPropertyDescription->getDataTypeName(), pPropertyDescription->getName(),
			pPropertyDescription->getDataTypeName());

		std::string name = pPropertyDescription->getName();
		name[0] = std::toupper(name[0]);
		sourcefileBody_ += fmt::format("\t\tpublic virtual void on{}Changed({} oldValue) {{}}\n", name, pPropertyDescription->getDataTypeName());
	}

	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKGodot::writeEntityProperty_FIXED_DICT(ScriptDefModule* pEntityScriptDefModule,
	ScriptDefModule* pCurrScriptDefModule, PropertyDescription* pPropertyDescription)
{
	sourcefileBody_ += fmt::format("\t\tpublic {} {} = new {}();\n", pPropertyDescription->getDataTypeName(), pPropertyDescription->getName(),
		pPropertyDescription->getDataTypeName());

	std::string name = pPropertyDescription->getName();
	name[0] = std::toupper(name[0]);
	sourcefileBody_ += fmt::format("\t\tpublic virtual void on{}Changed({} oldValue) {{}}\n", name, pPropertyDescription->getDataTypeName());
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKGodot::writeEntityProperty_VECTOR2(ScriptDefModule* pEntityScriptDefModule,
	ScriptDefModule* pCurrScriptDefModule, PropertyDescription* pPropertyDescription)
{
#ifdef CLIENT_NO_FLOAT
	sourcefileBody_ += fmt::format("\t\tpublic Vector2Int {} = {};\n", pPropertyDescription->getName(),
		(strlen(pPropertyDescription->getDefaultValStr()) > 0 ? pPropertyDescription->getDefaultValStr() : "new Vector2Int(0, 0)"));

	std::string name = pPropertyDescription->getName();
	name[0] = std::toupper(name[0]);
	sourcefileBody_ += fmt::format("\t\tpublic virtual void on{}Changed(Vector2Int oldValue) {{}}\n", name);
#else
	sourcefileBody_ += fmt::format("\t\tpublic Vector2 {} = {};\n", pPropertyDescription->getName(),
		(strlen(pPropertyDescription->getDefaultValStr()) > 0 ? pPropertyDescription->getDefaultValStr() : "new Vector2(0f, 0f)"));

	std::string name = pPropertyDescription->getName();
	name[0] = std::toupper(name[0]);
	sourcefileBody_ += fmt::format("\t\tpublic virtual void on{}Changed(Vector2 oldValue) {{}}\n", name);
#endif

	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKGodot::writeEntityProperty_VECTOR3(ScriptDefModule* pEntityScriptDefModule,
	ScriptDefModule* pCurrScriptDefModule, PropertyDescription* pPropertyDescription)
{
#ifdef CLIENT_NO_FLOAT
	sourcefileBody_ += fmt::format("\t\tpublic Vector3Int {} = {};\n", pPropertyDescription->getName(),
		(strlen(pPropertyDescription->getDefaultValStr()) > 0 ? pPropertyDescription->getDefaultValStr() : "new Vector3Int(0, 0, 0)"));

	std::string name = pPropertyDescription->getName();
	name[0] = std::toupper(name[0]);
	sourcefileBody_ += fmt::format("\t\tpublic virtual void on{}Changed(Vector3Int oldValue) {{}}\n", name);
#else
	sourcefileBody_ += fmt::format("\t\tpublic Vector3 {} = {};\n", pPropertyDescription->getName(),
		(strlen(pPropertyDescription->getDefaultValStr()) > 0 ? pPropertyDescription->getDefaultValStr() : "new Vector3(0f, 0f, 0f)"));

	std::string name = pPropertyDescription->getName();
	name[0] = std::toupper(name[0]);
	sourcefileBody_ += fmt::format("\t\tpublic virtual void on{}Changed(Vector3 oldValue) {{}}\n", name);
#endif

	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKGodot::writeEntityProperty_VECTOR4(ScriptDefModule* pEntityScriptDefModule,
	ScriptDefModule* pCurrScriptDefModule, PropertyDescription* pPropertyDescription)
{
#ifdef CLIENT_NO_FLOAT
	sourcefileBody_ += fmt::format("\t\tpublic Vector4Int {} = {};\n", pPropertyDescription->getName(),
		(strlen(pPropertyDescription->getDefaultValStr()) > 0 ? pPropertyDescription->getDefaultValStr() : "new Vector4Int(0, 0, 0, 0)"));

	std::string name = pPropertyDescription->getName();
	name[0] = std::toupper(name[0]);
	sourcefileBody_ += fmt::format("\t\tpublic virtual void on{}Changed(Vector4Int oldValue) {{}}\n", name);
#else
	sourcefileBody_ += fmt::format("\t\tpublic Vector4 {} = {};\n", pPropertyDescription->getName(),
		(strlen(pPropertyDescription->getDefaultValStr()) > 0 ? pPropertyDescription->getDefaultValStr() : "new Vector4(0f, 0f, 0f, 0f)"));

	std::string name = pPropertyDescription->getName();
	name[0] = std::toupper(name[0]);
	sourcefileBody_ += fmt::format("\t\tpublic virtual void on{}Changed(Vector4 oldValue) {{}}\n", name);
#endif

	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKGodot::writeEntityProperty_ENTITYCALL(ScriptDefModule* pEntityScriptDefModule,
	ScriptDefModule* pCurrScriptDefModule, PropertyDescription* pPropertyDescription)
{
	sourcefileBody_ += fmt::format("\t\tpublic byte[] {} = {};\n", pPropertyDescription->getName(),
		(strlen(pPropertyDescription->getDefaultValStr()) > 0 ? pPropertyDescription->getDefaultValStr() : "new byte[0]"));

	std::string name = pPropertyDescription->getName();
	name[0] = std::toupper(name[0]);
	sourcefileBody_ += fmt::format("\t\tpublic virtual void on{}Changed(byte[] oldValue) {{}}\n", name);
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKGodot::writeEntityMethod(ScriptDefModule* pEntityScriptDefModule,
	ScriptDefModule* pCurrScriptDefModule, MethodDescription* pMethodDescription, const char* fillString)
{
	sourcefileBody_ += fmt::format("\t\tpublic abstract void {}({}); \n", pMethodDescription->getName(), fillString);
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKGodot::writeEntityMethodArgs_ARRAY(FixedArrayType* pFixedArrayType, std::string& stackArgsTypeBody, const std::string& childItemName)
{
	// 对于匿名数组需要解析，否则直接填类型名称
	if (childItemName.size() == 0 || childItemName[0] == '_')
	{
		std::string typeStr;
		getArrayType(pFixedArrayType, typeStr);
		stackArgsTypeBody += typeStr;
	}
	else
	{
		stackArgsTypeBody += childItemName;
	}

	return true;
}
 
//-------------------------------------------------------------------------------------
bool ClientSDKGodot::writeEntityMethodArgs_Const_Ref(DataType* pDataType, std::string& stackArgsTypeBody)
{
	return true;
}


//-------------------------------------------------------------------------------------
}
